\documentclass[main.tex]{subfiles}

\usemintedstyle{bw}

\begin{document}

\newpart{part3}{ІАЛЦ.467100.003 ПЗ}
\tableofcontents

% I'm not yet sure I need a translation, so that may change in the
% future
\newcommand\engacro[3]{\acro{#1}{\acroextra{(}#2\acroextra{) #3}}}

\specialchapter{Список скорочень}
\begin{acronym}[EDSL]

  % To decrease spacing
  % \setlength\parskip{0ex}

  \engacro{AST}{Abstract Syntax Tree}{Абстрактне Синтаксичне Дерево}
  \engacro{DSL}{Domain-Specific Language}{Предметно-Орієнтована Мова}
  \engacro{EDSL}{Embedded Domain-Specific Language}{Вбудована Предметно-Орієнтована Мова}
  \acro{ELF}{Executable and Linkable Format}
  \engacro{FFI}{Foreign Function Interface}{Інтерфейс Зовнішньої Функції}
  \engacro{LTO}{Link Time Optimization}{Оптимізація Часу Зв'язування}
  \engacro{RAII}{Resource Acquisition Is Initialization}{Отримання ресурсу є ініціалізація}
  \engacro{RTOS}{Real-Time Operating System}{Операційна Система Реального Часу}
  \engacro{TCO}{Tail Call Optimization}{Оптимізація хвостових викликів}
  \acro{ООП}{Об'єкто-Орієнтоване Програмування}
\end{acronym}

\specialchapter{Вступ}

Насьогодні, найбільш розповсюдженою мовою для програмування вбудованих систем, є мова C, яка відома своєю складністю застосування і високим ризиком допустится складних для відлагодження помилок. Найпоширенішим стандартом є C99, що був випущений у 1999 році. Це означає, що мова практично зупинила своє еволюційування і не отримувала значних покращешь напротязі 18 останніх років.

Мова C++, навпроти, активно розвивається і вийшла на регулярні оновлення кожні три роки. Але ця мова обмежена зворотньою сумісністю, що не дозволяє виправити більшість помилок, що були успадковані від мови C. Мову C++ складна у використанні, а також не має захисту від великого класу помилок.

Наразі, автору роботи не відома сучасна мова програмування, що повністю б задовольняла його потребам.

У рамках даного дипломного проекту ставиться завдання розробити мову програмування призначену для низькорівневого програмування: вбудованих систем, систем реального часу, операційних систем, системних утиліт. Мова має включати сучасні здобутки теорії мов програмування, бути продуктивною, швидкою і безпечною у використанні.

При створенні програмного продукту було пройдено повний цикл його написання --- від постановки завдання, написання технічного завдання і вимог до продукту, до написання програмного забезпечення та тестування.

\chapter{Огляд мов низькорівневого програмування}

%\newcommand\LangC{Сі}
\newcommand\LangC{C}

\section{Загальні вимоги}

Програмування мікроконтролерів висуває певні вимоги до мови.

По-перше, мова має бути компілюєма, оскільки на дешевих мікроконтролерах дуже мало ресурсів для інтерпретації мови, або її компіляції. На більших платформах, інтерпретація можлива, але однаково вимагає додаткових витрат процесорного часу і пам'яті. Оскільки дана робота розглядає реалізацю операційної системи, що буде вимагати мінімального обсягу пам'яті, інтерпретація мови на мікроконтроллері неможлива.

По-друге, мова не повинна вимагати збирача сміття, або будь-якого іншої бібліотеки середовища виконання. Як і з інтерпретацією, це вимагає додаткових ресурсів, якими мікроконтролер часто не володіє.

По-третє, низькорівневе програмування схильне до програмних помилок, що важко знайти і виправити. На відміну від прикладного програмування, помилки на системному рівні частіше призводять до краху усієї системи. До найчастіших помилок можна віднести помилки виходу за границі буферу, помилки при роботі з динамічною пам'яттю, витік ресурсів, помилки синхронізації, виклик заборонених у певному контексті функцій. Це означає, що мови системного програмування мають приділяти особливу увагу питанню безпеки.

Також, для програмування операційних систем дуже важлива можливість контролювати розмітку пам'яті і робота з пам'яттю напряму. Додатковими плюсами є можливість вбудови асемблерних інструкцій, взаємодія з іншими мовами (зокрема мовою асемблера і \LangC{}), наявність якісного компілятора, що генерує швидкий код.

\section{C}

Мову \LangC{} було розроблено у 1972 році Денісом Рітчі у Bell Telephone Labaratories з метою написання операційної системи UNIX\cite{stewart-bill:history-of-c}. \LangC{} є однією із найпопулярніших у світі мов програмування за кількістю вже написаного програмного забезпечення, а також кількості програмістів.

Найпростіша програма мовою \LangC{} зображена на рисунку \ref{example:c}.

\begin{figure}[h]
  \centering
  \begin{minted}{c}
#include <stdio.h>

// This is an example of comment
int main(void)
{
  printf("Hello, world!\n");

  return 0;
}
  \end{minted}
  \caption{Приклад найпростішої програми мовою \LangC{}}
  \label{example:c}
\end{figure}

Мова \LangC{} надає можливості прямого доступу до пам'яті, майже повний контроль над пам'яттю і потоком виконання, не має збирача сміття, або будь-якої бібліотеки середовища виконання. Також, \LangC{} має просту домовленість про виклики, що дозволяє легко використовуваи функції, написані на \LangC{}, майже з будь-якої іншої мови програмування, включаючи мову асемблера. Існують дуже потужні і стабільні компілятори, що генерують високоефективний машиний код. Все це робить \LangC{} гарним кандидатом.

Мова \LangC{} є \emph{де-факто} стандартом для написання вбудованих систем. Це перевірений роками інструмент, що довів свою ефективність і показав себе найкращим у класі вбудованих систем.

Однак, \LangC{} не можна назвати сучасною мовою. Її було розроблено майже 50 років тому і сьогодні не ведеться активних розробок з покращення і розвинення мови. Останній стандарт (C11) було випущено у 2011 році, але він вносить лише незначні покращення і не виправляє багатьох фундаментальних проблем мови \LangC{}.

Однією із серйозних проблем \LangC{} є типізація. Мова \LangC{} має слабку статичну типізацію; це означає, що всі типи перевіряються на етапі компіляції, але існують неявні приведення типу, що досить часто призводить до програмних помилок. Також, система типів є дуже примітивною, і не має корисних функцій, що характерні більш сучасним системам типів.

\section{Idris}\label{sec:idris}

Мова Idris\cite{idris} є чисто-функціональною мовою програмування з потужною системою типів, що підтримує залежні типи. Розробка мови ведеться з 2009 року\cite{idris:first-release}, тож мова є дуже молодою.

Код найпростішої програми мовою Idris наведено на рисунку \ref{example:idris}.

\begin{figure}[h]
  \centering
  \begin{minted}{idris}
module Main

main : IO ()
main = putStrLn "Hello, world!"
  \end{minted}
  \caption{Приклад найпростішої програми мовою Idris}
  \label{example:idris}
\end{figure}

Насьогодні, залежні типи не є широко-використовуваною технологією у програмуванні і використовуються здебільшого у науковому середовищі, а також ентузіастами мов програмування. Залежні типи стирають межу між типами і значеннями; типи стають звичайними значеннями, що дозволяє виконувати операції над типами, передавати їх як аргументи функцій і повертати їх із функцій. Тож можна мати різний тип в залежності від результатів обчислення певного значення, або іншого типу.

За допомогою залежних типів в Idris було побудовано систему ефектів. Система ефектів дозволяє розділити використання певних дій від їх конкретної реалізації. Наприклад, функція може використовувати функції логування, однак вибір їх конкретної реалізації залишається на функції, що врешті решт викличе виконання ефекту. Це можна назвати формою впровадження залежностей (dependency injection).

\begin{figure}%[h]
  \centering
  \begin{minted}{idris}
module Effect.File

import Effects
import Control.IOExcept

FILE_IO : Type -> EFFECT

data OpenFile : Mode -> Type

open : (fname : String)
       -> (m : Mode)
       -> Eff Bool [FILE_IO ()]
                   (\res => [FILE_IO
                     (case res of
                       True => OpenFile m
                       False => ())])
close : Eff () [FILE_IO (OpenFile m)] [FILE_IO ()]

readLine  : Eff String [FILE_IO (OpenFile Read)]
writeLine : String -> Eff () [FILE_IO (OpenFile Write)]
eof       : Eff Bool [FILE_IO (OpenFile Read)]

Handler FileIO IO where { ... }
  \end{minted}
  \caption{Приклад використання залежних типів}
  \label{idris:dependent-types}
\end{figure}

Система ефектів також дозволяє керувати і розмежовувати доступ повних функції до певних ефектів. Наприклад, можна створити ефект для роботи з мережею; тоді можна обмежувати доступ до мережевих операцій на рівні окремих функцій -- компілятор може гарантувати під час компіляції, що певна функція не буде використовувати функції роботи з мережею.

Система ефектів і залежні типи можуть підвищити рівень надійності операційних систем, якщо правильно їх використовувати. За допомогою створення окремого класу блокуючих операцій, можна позбавитися від цілого класу проблем, що виникають при виклику блокуючих операцій з обробнику переривань. За допомогою ще інакшого ефекту, можна гарантувати вивільнення ресурсів, як то пам'ять або відкриті файлові дескриптори. За допомогою залежних типів можна накладати обмеження на виділення оперативної пам'яті, або навіть на кількість тактів процесора для певних функцій. В цілому, залежні типи це дуже потужних механізм для забезпечення перевірки певних припущень у самомоу коді програми і математичного доведення правильності програми.

Нажаль, Idris вимагає збирача сміття і великої бібліотеки часу виконання, що унеможливлює використання Idris напряму для створення програмного забезпечення для систем з обмеженою пам'яттю. Але можливо створити EDSL (embedded domain-specific language, вбудована предметно-орієнтована мова) на базі Idris для генерація коду для вбудованих систем і таким чином позбутися даних обмежень мови. Схожим чином було реалізовано мови Atom\cite{haskell:atom} і Ivory\cite{haskell:ivory}, але на базі мови Haskell\cite{haskell}.

\section{Nim}

\begin{figure}[!bp]
  \centering
  \begin{minted}{nim}
# This is comment

# All top-level statements are
# executed when program starts
echo "Hello, world!"
  \end{minted}
  \caption{Приклад найпростішої програми мовою Nim}
  \label{example:nim}
\end{figure}

Мова Nim\cite{nim} (раніше Nimrod) вперше зв'явилася у 2008 році. Це багатопарадигмена мова, що компілюється у Javascript або \LangC{}, має сильну статичну типізацію і простий синтаксис. Nim має багаті можливості узагальненого (Generics), об'єктно-орієнтованого і шаблонного програмування. Особливо варто відмітити багаті можливості для обчислень під час компіляції. Макроси дозволяють змінювати AST (Abstract Syntax Tree, Абстрактне Синтаксиче Дерево) програми під час компіляції; за допомогою них можна як робити обчислення під час компіляції, так і змінювати синтаксис мови і розширювати його.

Nim також має спрощену систему ефектів. На відміну від системи ефектів в Idris, система ефектів в Nim дозволяє лише маркувати функції різними ефектами i відслітковувати їх. Цього достатньо для того, щоб уникнути програмних помилок пов'язаних з викликом функцій, що заборонені у даному контексті, однак, системи типів Nim не вистачає, щоб гарантувати вивільнення ресурсів, або робити більш складні речі з типами (наприклад, неможливо будувати докази).

Також, Nim має велику кількість директив компілятора\cite{nim:directives}, що можуть бути цікаві під час низькорівневого програмування. Однією із таких директив є прагма \code{effects}, яка і є вже оговореною системою ефектів. Також цікавою є пара прагм \code{guard} і \code{locks}, що дозволяють гарантувати використання промаркованих ресурсів у багатопотокових програмах використовуючи блокування. При цьому, Nim може гарантувати правильний порядок захоплення ресурсів за допомогою рівнів.

Nim має цілу низку директив компілятора, що дозволяють вставляти код написаний на мові \LangC{}, C++, або Objective-C. Це може бути дуже зручним, якщо необхідно багато взаємодіяти з іншими бібліотеками написаними на цих мовах.

За рахунок прагм Nim є дуже загальною мовою програмування, що можна використовувати для широкого спектру задач і середовищ. За допомогою директив компілятора можна контролювати передачу аргументів функцій (за значенням, за посиланням), можна вказувати підказки оптимізатору (розгортка циклів, вбудова викликів функцій, позначення для функцій, що не повертаються або не мають побічних ефектів), можна точно керувати схемою пам'яті (бітові поля, вирівнювання полів, генерація стек-фреймів), також збірник сміття є опціональним і його можна виключити за необхідності.

Нажаль, під час більш детального аналізу було виявлено серйозний недолік в реалізації компілятора. Прагму \code{volatile} було реалізовано некоректно\cite{nim:volatile}, що унеможливило нормальне використання мови для низькорівневого програмування.

\section{Rust}

Rust\cite{rust} це молода багатопарадигмена компілюєма мова для системного програмування, що активно розвивається. Мова вперше з'явилася у 2010 році і була розроблена компанією Mozilla\cite{rust:mozilla}. Мова націлена на безпечне і багатопотокове програмування і має низку особливостей, що цьому допомагають.

\begin{figure}[h]
  \centering
  \begin{minted}{rust}
// This is a comment.

// This is the main function
fn main() {

  // Print text to the console
  println!("Hello, world!");
}
  \end{minted}
  \caption{Приклад найпростішої програми мовою Rust}
  \label{example:rust}
\end{figure}

Основною функціональною особливістю мови є потужна система типів. Типізацію у Rust є статичною і сильною, що дозволяє уникнути широкого класу помилок зумовлених неявним приведенням типів. Система типів у Rust також є лінійною; це характеристика, що дозволяє уникати помилок розділення ресурсів у багатопотоковому програмуванні за допомогою системи типів (без блокування). Система типів у Rust дозволяє мати лише одне посилання на об'єкт, за яким можна змінювати його, або безліч посилань, за якими можна лише зчитувати дані. Неможливо одночасно мати два посилання на об'єкт, що дозволяють зчитувати і змінювати дані. Це дозволяє уникнути багатьох помилок у багатопотоковому програмуванні уже під час компіляції, без будь-яких витрат під час роботи.

Також, Rust має чітке розмежування між так званими безпечним і небезпечним рівнями. У безпечному рівні заборонено використання певних операцій, що можуть призвести до помилок (наприклад, заборонено використання звичайних вказівників на пам'ять). Це дозволяє мові забезпечити певні гарантії. За замовчуванням, функції є безпечними, а для використання небезпечних операцій необхідно позначити функцію або блок коду як небезпечний. Це дозволяє локалізувати код, що може викликати проблеми.

Інує реалізація простої системи ефектів у вигляді бібліотеки.

Rust також надає багато можливостей, що необхідні для низькорівневого програмування: точне керування схемою пам'яті, гарну взаємодію з мовою \LangC{}, відсутність збірника сміття і бібліотеки часу виконання. Компілятор Rust використовує LLVM\cite{llvm} для компіляції, що дозволяє йому генерувати ефективний код для великої кількості платформ.

Rust також має синтаксис дуже схожий до мови \LangC{}, що є плюсом для широкого розповсюдження мови, оскільки даний синтаксис є відомим багатьом програмістам.

\chapterconslusions{}

Мова \LangC{} є гарним вибором для комерційного проекту, але не надає ніяких технічних переваг. Використання даної мови не несе собою новизни і не цікаве з точки зору дослідження.

Idris має одну із найпотужніших систем типів насьогодні. Її особливості можна було б використати для створення значно більш надійних операційних систем. Нажаль, Idris вимагає збирача сміття і великої бібліотеки середовища виконання. Це унеможливлює використання Idris для операційних систем для вбудованих пристроїв напряму. Розробка EDSL на Idris може бути виходом, але вимає додаткових затрат.

Nim є дуже цікавою мовою, що має опціональний збиральник сміття і може працювати без бібліотеки середовища виконання. Вона має багато особливостей, що можуть допомогти при написанні низькорівневого програмного забезпечення. Однак, низька якість реалізації компілятора майже унеможливлює використання мови для більш-менш серйозного низькорівневого програмування.

Система типів Rust є гарним компромісом між потужною системою типів Idris, яка вимагає певної підтримки від середовища виконання, і системи типів \LangC{}, що не потребує середовища виконання, але є занадто простою. За допомогою типів, Rust допомагає гарантовано уникнути певного класу помилок, що є розповсюдженими при низькорівневому програмуванні. Також, розділення на безпечні і небезпечні операції дозволяє локалізувати код, що може викликати програмні помилки.

\chapter{Проектування мови}
\section{Аналіз середовища і обмежень}
Програмування для вбудованих систем накладає досить велику кількість обмежень і висуває багато специфічних вимог до мови --- саме через це існує дуже мало мов програмування, що можуть бути використані для даних цілей.
Саме тому, для початку проектування мови, необхідно визначити основні обмеження і вимоги.

Розглянемо особливості оточення на прикладі мікроконтроллерів ARM серії Cortex-M\cite{cortex-m} і їх реалізації від STMicroelectonics\cite{cortex-m:stm}. Мікроконтроллери серії Cortex-M це сімейство глибоко вбудованих процесорів, оптимізованих для застосувань, що чутливі до витрат.

\newcommand\elfsection[1]{\texttt{#1}}

\begin{itemize}[nosep]
\item \textbf{Низький об'єм RAM}. Об'єми оперативної пам'яті складають від 2 Кілобайт до 1 Мегабайта. Типові об'ями оперативної пам'яті, з якими доводилося працювати автору --- 16--256 Кілобайт. Оперативна пам'ять включає в себе \elfsection{.data} і \elfsection{.bss} секції; гарною новиною є те, що секція \elfsection{.code} не входить в даний об'єм, оскільки процесор виконує програминй код з ROM без завантаження в оперативну пам'ять.

\item \textbf{Низький об'єм ROM}. Об'єми вбудованої флеш пам'яті варіюються від 8 Кілобайт до 2 Мегабайт. Типовими є розміри до 1 Мегабайту. Через особливості завантаження прошивки, до складу ROM входять наступні секції: \elfsection{.text} (код), \elfsection{.rodata} (константи доступні лише для читання), \emph{а також} \elfsection{.data} (ненульові початкові значення для статичних змінних), що уже була включена до об'єму RAM.

\item \textbf{Обмежене живлення}. Багато вбудованих систем живляться від батарей, що означає, що програмісти мають перейматися питаннями збереження енергії, включаючи утримання процесора в режимі сну більшість часу (буквально, більше 99\% всього часу\cite{processor-sleep}).

\item \textbf{Програмісти дешеві; апаратне забезпечення дороге}. На відміну від більшості інших областей програмування\cite{hardware-is-cheap}, додавання потужності апаратного забезпечення означає, що ціна продукту збільшується для \emph{всіх} кінцевих користувачів. Тому, зазвичай, дешевше використати додатковий час програмістів для оптимізації коду, аніж обрати більш потужний чип. Також, потужніші процесори споживають більше енергії, що означає збільшення об'єму батарей, що збільшує ціну ще більше (не кажучи про збільшеня розмірів пристрою).

\item \textbf{Передбачуваність}. Багато вбудованих систем мають м'які або жорсткі вимоги реального часу. Це означає, що система забов'язана забезпечити відповідь в обмежених часових рамках. На практиці, це означає, що використання багатьох планувальників, збірників сміття, алокаторів пам'яті, або навіть виключень заборонене.

\item \textbf{Безпечність}. Система має бути надійною, оскільки в інакшому випадку можуть загинути люди. З цієї причини існує багато стандартів, таких як MISRA\cite{misra}, що вимагають дотримання певної дисципліни і дуже часто забороняють використання певних можливостей мови.

\item \textbf{Відлагодження програмних помилок важке}. Зазвичай, вбудовані пристрої не мають засобів для захисту від некоректного використання пам'яті, через що багато помилок проявляються в абсолютно не пов'язаних частинах системи, через деякий час, без трасування стеку і будь-яких підказок. Через це, відлагодження помилок у вбудованих системах є ще довшим і дорожчим, ніж в інших областях програмування.

\item \textbf{Компіляція без середовища виконання}. Мова забов'язана компілюватися.

\begin{enumerate}[nosep]
\item Процесори просто не мають ресурсів для JIT-компілятора або іншого середовища виконання.
\item JIT компіляція погіршує передбачуваність, оскільки час компіляції і паузи здебільшого важко піддаються передбаченню.
\item JIT практично вимагає виконання коду з оперативної пам'яті. Не беручи до уваги обмежену кількість оперативної пам'яті, виконання коду з оперативної пам'яті погіршує продуктивність, оскільки процесори ARM мають виділену лінію для витягування коду з флеш-пам'яті.
\end{enumerate}

Необхідно зазначити, що мова може підтримувати декілька форм виконання. Наприклад, вона може одночасно підтримувати компіляцію в машиний код, код віртуальної машини JVM, JavaScript, а також Vimscript, Lisp, і Whitespace.

З тих самих причин (обмежена кількість оперативної пам'яті), мова не має містити збірника сміття (або принаймні робити його опціональним).
\end{itemize}

\section{Основні цілі і принципи мови}
Для того, щоб спроектувати мову, необхідно сфокусувати свою увагу на найбільш суттєвих характеристиках, визначитися з основними цілями, напрямками і принципами мови.

Головним фокусом розроблюваної мови є зменшення кількості програмних помилок, що допускають програмісти.

Зменшення кількості помилок означає зменшення часу затраченого на відлагодження програм, підвищення надійності, а також зменшення кількості потенційних дір у безпеці.
Однак, не можна нехтувати продуктивністю і іншими критичними для системного програмування характеристиками.

Далі наведено список основних принципів, якими необхідно керуватися при розробці мови.

\subsection{Безпечність}
Мова має запобігати і унеможливлювати максимально велику кількість типових помилок, що допускають програмісти. Але при цьому, мова на має обмежувати можливості програміста і має дозволяти йому реалізувати будь-який функціонал.

\subsection{Простота і явність}
Прості мови набагато легше зрозуміти і розмірковувати про них, що призводить до зменшення кількості програмних помилок. Явність робить мову більш простою і передбачуваною.

Яскравим контр-прикладом є мова C++, яка має велику кількість правил, неочевидних виключень і славиться своєю складністю.

Розроблювана мова має бути максимально ``прозорою'' і очевидною для програміста. Це означає, що мова має бути ``простою'': містити мало виключень з правил, а також виконувати мінімальну кількість неявних дій. Передбачувані мови мінімізують шанс неправильної інтерпретації людиною, що зменшує кількість неочікуваної поведінки, що, зазвичай, призводить до програмних помилок.

\subsection{Продуктивність}
Мова має мінімізувати накладні витрати на забезпечення безпеки. Швидкодія програм, написаних на розроблюваній мові, має бути порівнювана з аналогічними програмами написаними на мові \LangC{}.
За можливості, перевага надається абстраціям з нульовою вартістю.

\subsection{Сучасність}
Розроблювана мова має надавати сучасні можливості для створення абстракцій.
Мова має включати \todo{write this section}

\subsection{Найгірші практики повинні бути важкими}
Є велика різниця між ``підтримується мовою'' і ``заохочується мовою''.

Гарним прикладом є константні змінні. І \LangC{}, і Rust підтримують константність змінних, але константи в Rust є більш поширеними. Причиною цього є те, що в мові Rust всі змінні константні за замовчуванням, а для неконстантних змінних вимагається додаткове слово (\code{let} проти \code{let mut}). Тому програмісти використовують константи, окрім випадків, коли змінність необхідна. (Окрім того, компілятор Rust видає діагностичне повідомлення, якщо неконстантна змінна ніколи не змінювалася). З іншого боку, мова \LangC{} навпаки вимагає введення додаткового слова \code{const}, що призводить до того, що більшість змінних є неконстантними, навіть якщо цього не потребується.

%\cite{worst-practices-should-be-hard}

\section{Аналіз типових помилок}
Для того, щоб ефективно запобігати помилкам, необхідно більш детально дослідити їх.

\subsection{Аналіз 1}\label{errors:os}
В рамках секції \ref{errors:os} розглядаються результати наукової статті ``An Empirical Study of Operating Systems Errors''\cite{an-empirical-study-of-operating-systems-errors}.

Згідно до статті, найрозповсюдженіші помилки наведено у тaблиці \ref{linux-errors}.
Більшість даних помилок можна обмежити засобами мови. Таблиця \ref{linux-errors-mitigation} підсумовує можливі варіанти.

\begin{table}
  \tabulinesep=1mm
  \begin{tabu}{|c|c|X[l]|}
    \hline
    Check & Nbugs & Rule checked \\
    \hline\hline
    \code{Block} & 206 + 87 & To avoid deadlock, do not call blocking functions with interrupts disabled or a spinlock held. \\
    \code{Null} & 124 + 267 & Check potentially NULL pointers returned from routines. \\
    \code{Var} & 33 + 69 & Do not allocate large stack variables (> 1K) on the fixed-size kernel stack. \\
    \hline\hline
    \code{Inull} & 69 & Do not make inconsistent assumptions about whether a pointer is \code{NULL}. \\
    \code{Range} & 54 & Always check bounds of array indices and loop bounds derived from user data. \\
    \code{Lock} & 26 & Release acquired locks; do not double-acquire locks. \\
    \code{Intr} & 27 & Restore disabled interrupts. \\
    \code{Free} & 17 & Do not use freed memory. \\
    \hline\hline
    \code{Float} & 10 + 15 & Do not use floating point in the kernel. \\
    \code{Real} & 10 + 1 & Do not leak memory by updating pointers with potentially \code{NULL} realloc return values. \\
    \code{Param} & 7 & Do not dereference user pointers. \\
    \code{Size} & 3 & Allocate enough memory to hold the type for which you are allocating. \\
    \hline
  \end{tabu}
  \caption{Найрозповсюдженіші помилки у ядрі Linux}
  \label{linux-errors}
\end{table}

\begin{table}
  \tabulinesep=1mm
  \begin{tabu}{|c|X[l]|}
    \hline
    Перевірка & Засоби попередження \\
    \hline\hline
    \code{Block} & Система ефектів \\
    \code{Null} & Використання посилань замість вказівників \\
    \code{Var} & Розрахунок максимального розміру стеку, модифікована система ефектів \\
    \hline\hline
    \code{Inull} & Система ефектів, використання вказівників \\
    \code{Range} & Автоматична перевірка границь, залежні типі, система ефектів, liquid типи \\
    \code{Lock} & Деструктори (RAII) \\
    \code{Intr} & Деструктори (RAII) \\
    \code{Free} & Лінійна система типів, RAII \\
    \hline\hline
    \code{Float} & Система ефектів \\
    \code{Real} & Дизайн правильних інтерфейсів і абстракцій \\
    \code{Param} & Система ефектів застосована до зміних, легкі обгортки навколо інших типів \\
    \code{Size} & Дизайн правильних інтерфейсів \\
    \hline
  \end{tabu}
  \caption{Засоби мови, що можуть запобігти помилкам}
  \label{linux-errors-mitigation}
\end{table}

\subsection{Аналіз 2}\label{linux-kernel-developer-responses-section}
Секція \ref{linux-kernel-developer-responses-section} аналізує дані про розповсюдженість помилок, що були зібрані в рамках дослідження ``Linux Kernel Developer Responses to Static Analysis Bug Reports''\cite{linux-kernel-developer-responses}.

Зазначене дослідження наводить наступні типи помилок:
\begin{enumerate}[nosep]
\item dynamic buffer overrun
\item read of uninitialized values
\item dead code
\item static buffer overrun
\item unsafe use before negative test
\item type/allocation size mismatch
\item unsafe use before null test
\item resource leak
\item null pointer dereference
\item unsafe use of null return value
\item use resource after free
\item unsafe use of negative return value
\end{enumerate}

\subsection{Аналіз 3}\label{errors:variability}
Секція \ref{errors:variability} аналізує дані про розповсюдженість помилок, що були зібрані в рамках дослідження ``40 Variability Bugs in the Linux Kernel. A Qualitative Study''\cite{40-variability-bugs}.

Таблиця \ref{variability-errors} підсумовує помилки виявлені в межах дослідження разом зі шляхами їх уникнення на рівні мови.

\begin{table}
  \tabulinesep=1mm
  \begin{tabu}{|c|l|X[l]|}
    \hline
    Частота & Тип помилки & Спосіб уникнення \\
    \hline\hline
    15 & Memory errors: & \\
    4 & null pointer dereference & Використання посилань \\
    3 & buffer overflow & Автоматична перевірка границь, залежні типи, liquid типи \\
    3 & read out of bounds & Автоматична перевірка границь, залежні типи, liquid типи \\
    2 & insufficient memory & \\
    1 & memory leak & RAII \\
    1 & use after free & RAII, лінійна система типів \\
    1 & write on read only & Посилання, що доступні лише для читання \\
    \hline
    8 & Compiler warnings: & \\
    5 & uninitialized variable & Попередження компілятора, вимога ініціалізації змінних \\
    1 & unused function (dead code) & Попередження компілятора \\
    1 & unused variable & Попередження компілятора \\
    1 & void pointer dereference & Строга система типів \\
    \hline
    7 & Type errors: & \\
    5 & undefined symbol & Перевірка компілятора \\
    1 & undeclared identifier & Перевірка компілятора \\
    1 & wrong number of args to function & Перевірка компілятора \\
    \hline
    7 & Assertion violations: & \\
    5 & fatal assertion violation & \\
    2 & non-fatal assertion violation & \\
    \hline
    2 & API violations: & \\
    1 & Linux sysfs API violation & Більш потужні засоби для забезпечення дотримання інтерфейсів \\
    1 & double lock & Лінійна система типів \\
    \hline
    1 & Arithmetic errors: & \\
    1 & numeric truncation & Заборона неявних преведень типів, автоматична перевірка переповнень \\
    \hline
  \end{tabu}
  \caption{Часті помилки і способи їх уникнення}
  \label{variability-errors}
\end{table}

\section{Дизайн}

\subsection{Сімейство синтаксису}
Окрім широко-відомого C-подібного сімейства синтаксису, існує досить багато інших популярних синтаксисів, що дозволяють писати більш компактний код.

Зокрема варто відмітити синтаксис мови Python і ML-подібний синтаксис, прикалади яких наведено на рисунках \ref{python-syntax} і \ref{ml-syntax}, відповідно.

\begin{figure}[h]
  \centering
  \begin{minted}{python}
def mymin(a, b):
    if a < b:
        return a
    else:
        return b
  \end{minted}
  \caption{Приклад синтаксису мови Python}
  \label{python-syntax}
\end{figure}

\begin{figure}[h]
  \centering
  \begin{minted}{haskell}
mymin :: Int -> Int -> Int
mymin a b = if a < b then a else b
  \end{minted}
  \caption{Приклад ML-подібного синтаксису (Haskell)}
  \label{ml-syntax}
\end{figure}

Чутливий до відступів синтаксис мови Python не використовує фігурні дужки для відокремлення вкладених блоків, що дозволяє зекономити вертикальний простір і вмістити більше діючого коду на екран. ML-подібний синтаксис іде ще далі і має дуже мінімальний синтаксис, що використовує принцип зіставлення (juxtaposition) і не вимагає додаткових ключових слів і дужок для визначення або виклику функцій, що робить код ще більш компактним.

Однак, не варто забувати, що цільову аудиторію розроблюваної мови складають програмісти, що уже працюють із такими мовами як \LangC{} і C++. Для того, щоб полегшити перехід даних програмістів і сприяти ширшому сприйняттю, розроблювана мова повинна мати C-подібний синтаксис.

\subsection{Сумісність з мовою \LangC{}}
Мова забов'язана бути сумісною з \LangC{}, оскільки на цій мові написано дуже багато існуючих бібліотек, включаючи бібліотеки підтримки від постачальників апаратного забезпечення.

Підтримка зовнішнього інтерфейсу функцій мови \LangC{} не є важкою задачею і вже було реалізовано в багатьох мовах.
Більш тісна інтеграція включає в себе синтаксичний аналіз заголовочних файлів мови \LangC{} для витягнення і забезпечення типів функцій, розгорнення макросів і т.д.

Мова Nim гарно справляється з цією частиною (що не є дивним, оскільки вона компілюється в \LangC{}).

Розроблювана мова має підтримувати зовнішний інтерфейс функцій мови \LangC{}.

\subsection{Відсутність неявних приведень}
Неявні приведення відбуваються, коли аргументи операції не відповідають необхідним, але компілятор ``знає'', як привести один тип до іншого. При цьому, в мові \LangC{}, саме значення може змінитися: обрізатися до меншої кількості біт, або змінити знак. Оскільки компілятор може вставляти такі приведення неявно без відома програміста, це часто призводить до неочевидних і складних для відлагодження програмних помилок.

Розроблювана мова не має містити жодних неявних перетворень типів, для уникнення цих проблем --- навіть розширючих перетворень між числовими типами з однаковою знаковістю.

Ця ідея не є новою, і вже успішно реалізована у таких мовах як Haskell або Rust.

Підтвердженням доречності цієї ідеї є також те, що стандарт MISRA C забороняє використання більшості неявних перетворень.

\subsection{Константні змінні}
Відомо, що константні змінні полегшують читання програмного коду, оскільки значення, що були встановлені один раз, уже не будуть змінені, тому програмістам нема необхідності ментально відслідковувати, як використовується ця змінна. Окрім того, константі змінні допомагають програмістам гарантувати, що певні значення або ділянки пам'яті ніколи не будуть змінені --- це буває досить доречним в програмуванні для вбудованих систем.

Хоча існує досить багато мов, що навіть не підтримують константні змінні (наприклад, Java, Python), це досить важлива можливість для мови у сфері програмування для вбудованих систем і систем, що потребують високої надійності.

Цікаво відмітити, що існують мови, що взагалі не підтримують неконстантні змінні (Haskell, Idris). Однак, така реалізація мови вимагає занадто високих накладних витрат, щоб бути практичною у сфері системного програмування.

Розроблювана мова має включати можливість створювати константні змінні і, більш того, всі змінні мають бути константними за замовчуванням. Компілятор має видавати діагностичні повідомлення, якщо неконстантна змінна ніколи не змінюється.

\subsection{Система ефектів}
Спрощена система ефектів дозволить відмічати окремі функції ефектами, які вони мають. Наприклад:
\begin{itemize}[nosep]
\item Функція алокує пам'ять.
\item Блокуюча функція.
\item Функція, що виконує ввід/вивід.
\item Функція, що взаємодіє з мережею.
\end{itemize}

Компілятор може автоматично вивести ефекти інших функцій, що дозволяє миттєво дізнатися відповіді на такі питання як ``чи алокує дана функція пам'ять?''. Іншою частиною системи ефектів це можливість явно дозволяти або забороняти окремі ефекти для певних функцій. Наприклад, це дозволить заборонити викликати блокуючі функції із обробників переривань (одна із найбільш розповсюджених помилок в ядрі Linux), і забезпечити виконання цієї умови під час компіляції.

\subsection{Розділення безпечного і небезпечного коду}
Мова Rust дозволяє розділяти так званий ``безпечний'' і ``небезпечний'' код.
В межах безпечного коду дозволено виконувати лише певну підмножину всіх доступних операцій, в той час як в небезпечних блоках можна виконувати будь-які дії, що підтримуються мовою.
Наприклад, в безпечних секціях не дозволенo розіменовувати вказівники, або викликати інші небезпечні функції.

Використання лише безпечної підмножини мови гарантує безпеку пам'яті. Якщо програма зазнає помилок пов'язаних із пам'яттю (наприклад, розіменування неіснуючого вказівника), помилка гарантовано знаходить в ділянці коду, що помічена як ``небезпечна''.

Ця можливість мови є корисною для зебезпечення більшої надійності програм. І хоча загальна ідея є схожою із системою ефектів, розділення коду на безпечний і небезпечний потребує додаткової підтримки від компілятора.

\subsection{Асемблерні вставки}
Низькорівневе програмування потребує доступу до спеціальних інструкцій процесора, що не можуть бути реалізовані безпосередньо в мові через їх різноманіття і специфічність.

Прикладом такого використання є реалізація переключення контексту в ядрах операційних систем. В рамках даного процесу необхідно зберігти значення всіх регістрів на стеці і потім відновити значення регістрів іншого процесу.
Іншим прикладом є зчитування значень статусних регістрів (які залежать від архітектури процесора).

Зазвичай, ці функції реалізуються за допомогою асемблерних вставок. Стандарт мови \LangC{} не включає даних механізміх, але більшість компіляторів мови \LangC{} реалізовують це власноруч.

Розроблювана мова має включати стандартні механізми для використання асемблерних вставок.

\subsection{Розширена підтримка лінковки}
Програмістам вбудованих систем доводиться вручну керувати розміщенням даних і коду програми за певними адресами.

Наприклад:
\begin{itemize}[nosep]
\item Розміщення вектору переривань на фіксованій позиції.
\item Регістри відображені в пам'яті.
\item Підтримка різних карт пам'яті.
\end{itemize}

Наразі, це реалізується за допомогою розміщенням змінних по різним секціям і використання скриптів лінковки для розміщення секцій в необхідних фрагментах адресного простору.

Розроблювана мова має підтримувати принаймні розміщення зміних у заданих секціях. Підтримка задання опису секцій і їх розміщення в адресному просторі є додатковим плюсом.

\subsection{Узагальнене програмування}
Узагальнене програмування зарекомендувало себе як важливий інструмент програмування в останні десятиріччя. Це одна із найбільш затребуваних функція, якої не хватає в мові \LangC{}, оскільки вона дозволяє створювати типо-безпечні колекції об'єктів і алгоритми.

Узагальнене програмування реалізоване у мові C++ за допомогою шаблонів, а також у мові Java (і багатьох інших) за допомогою дженериків.

Розроблювана мова має підтримувати засоби узагальненого програмування.

\subsection{Типажі}
Типажі є альтернативою стандартним механізмам ООП для забезпечення поліморфізму. На відміну від ООП, типажі дозволяють лише наслідування інтерфейсу, але не наслідування імплементації.

Відомо, що наслідування імплементації значно поскладнює розуміння програм, а також руйнує інкапсуляцію\cite{oop-must-die}.
Типажі, навпроти, значно простіше для загального розуміння, мають менше виключень і кутових випадків, при цьому є достатньо потужними для реалізації складних програм.

\subsection{Умовна компіляція}
Код операційних систем зазвичай містить дуже багато апаратно-залежних деталей, які можуть бути використані (або навіть просто скомпільовані) лише для кількох окремих апаратних платформ.
Незважаючи на це, загальна структура операційних систем є універсальної і працює однаково незалежно від цільової платформи.
Це можливо тільки за рахунок так званої ``умовної компіляції''.

Умовна компіляція дозволяє вмикати або вимикати певні фрагменти програмного коду в залежності від певних умов, що можуть перевірятися під час компіляції.

У мові \LangC{}, дана можливість представлена препроцесором, а саме директивами \code{\#if} та \code{\#ifdef}, \code{\#ifndef}, \code{\#else}, \code{\#elif} та \code{\#endif}. Приклад використання умовної компіляції наведено на рисунку \ref{conditional-compilation}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{c}
#ifdef __unix__ /* __unix__ is usually defined by compilers targeting Unix systems */
# include <unistd.h>
#elif defined _WIN32 /* _WIN32 is usually defined by compilers targeting 32 or 64 bit Windows systems */
# include <windows.h>
#endif
  \end{minted}
  \caption{Приклад використання умовної компіляції}
  \label{conditional-compilation}
\end{figure}

Розроблювана мова повинна мати механізми для підтримки умовної компіляції.

\subsection{Вирази часу компіляції}
Вирази часу компіляції це можливість компілятора виконувати розрахунки під час компіляції програм, що дозволяє виконувати ще більше оптимізацій.

Можливість здійснювати нетривіальні розрахунки на етапі компіляції дозволяє пришвидшити програми (оскільки не треба буде робити ці розрахунки під час виконання) і зекономити пам'ять (оскільки результат зазвичай займає менше місця).

Також, вирази часу компіляції роблять умовну компіляцію більш потужною, оскільки дозволяють перевіряти більш складні умови.

\subsection{Розрахунок максимального розміру стеку на етапі компіляції}
Програми для вбудованих систем майже завжди працюють зі стеком фіксованого розміру. Одна із розповсюджених помилок --- це розміщення великих об'єктів на стеці, що призводить до його виснаження.

За відсутності рекурсії, компілятор має змогу розрахувати максимальний об'єм стеку, що може бути використаний будь-якою функцією. Це, в свою чергу, допоможе гарантувати, що програма ніколи не вийде за виділений для неї об'єм стеку.

\subsection{Опціональні перевірки часу виконання}
Компілятор розроблюваної мови може вставляти додаткові перевірки часу виконання для відлавлювання ще більшої кількості програмних помилок.

Прикладами таких перевірок можуть бути:
\begin{itemize}[nosep]
\item Перевірка виходу за границі масиву перед зверненням до комірки пам'яті.
\item Перевірка виходу за границі програмного стеку.
\item Перевірка переповнення цілочисельних значень перед виконанням арифметичних операцій.
\item Перевірка ділення на нуль.
\item Перевірка значення вказівника на \code{NULL}.
\end{itemize}

Переповнення буферу є однією із найрозповсюдженіших програмних помилок, що призводять до вразливостей безпеки, і є причиною багатьох відомих дір в безпеці, в тому числі Heartbleed\cite{heartbleed} і Blueborne\cite{blueborne}.
Включення даних перевірок за замовчуванням допоможе запобігти широкого класу таких помилок і підвищити безпеку програм.

Однак, недоліком даних перевірок є те, що вони використовують додаткові цикли процесора і тим самим зменшують продуктивність скомпільованих програм, оскільки, в загальному випадку, ці перевірки не можуть бути виконані на етапі компіляції і мають бути застосовані лише під час виконнання (хоча компілятор і може усунути деякі перевірки за допомогою статичного аналізу коду).

Додаткові перевірки часу виконання мають бути включеними за замовчуваннями, але компілятор має надавати можливість вимкнути окремі класи перевірок для програм, які потребують максимальної продуктивності.

\subsection{Гарантована оптимізація хвостових викликів}
Хвостовий виклик, це виклик процедури, що виконується як фінальна дія процедури.

Оптимізація хвостових викликів (Tail Call Optimization, TCO) це техніка, що дозволяє імплементацію хвостових викликів без додавання нових стекових кадрів (stack frame) до стеку викликів. Наприкінці виконання процедури, більшість її активного стекового кадру вже не потрібна, одже може бути заміщена стековим кадром хвостового виклику. Після цього, програма може стрибнути на процедуру, що викликається. Ця техніка також називається ``усунення хвостових викликів''.

За допомогою даної оптимізації стає можливим реалізація певних рекурсивних алгоритмів без росту розміру стеку викликів.
Це може бути важливим для програмування вбудованих систем, оскільки майже завжди розмір стеку є обмеженим.

\section{Опис мови}
\subsection{Коментарі}

% \chapterconslusions{}

% \chapter{Реалізація системи та тестування}
% \chapter{Аналіз отриманих результатів}

\begin{thebibliography}{00}
  \bibitem{stewart-bill:history-of-c}
    \eresource{History of C Programming Language}{http://www.livinginternet.com/i/iw\_unix\_c.htm}

  \bibitem{idris}
    \eresource{Idris | A Language with Dependent Types}{http://www.idris-lang.org/}
  \bibitem{idris:first-release}
    \eresource{idris: Dependently Typed Functional Programming Language}{http://hackage.haskell.org/package/idris-0.1.3}
  \bibitem{haskell:atom}
    \eresource{atom: An EDSL for embedded hard realtime applications}{https://hackage.haskell.org/package/atom}
  \bibitem{haskell:ivory}
    \eresource{Ivory - index}{http://ivorylang.org/index.html}
  \bibitem{haskell}
    \eresource{Haskell Language}{https://www.haskell.org/}

  \bibitem{nim}
    \eresource{Nim Programming Language}{http://nim-lang.org/}
  \bibitem{nim:directives}
    \eresource{Nim Manual}{http://nim-lang.org/docs/manual.html\#pragmas}
  \bibitem{nim:volatile}
    \eresource{\{.volatile.\} is almost useless · Issue \# 3382 · nim-lang/Nim}{https://github.com/nim-lang/Nim/issues/3382}

  \bibitem{rust}
    \eresource{The Rust Programming Language}{https://www.rust-lang.org/}
  \bibitem{rust:mozilla}
    \eresource{The Rust Language | Lambda the Ultimate}{http://lambda-the-ultimate.org/node/4009}
  \bibitem{llvm}
    \eresource{The LLVM Compiler Infrastructure Project}{http://llvm.org/}

  \bibitem{cortex-m}
    \eresource{Cortex-M -- Arm}{https://www.arm.com/products/processors/cortex-m}
  \bibitem{cortex-m:stm}
    \eresource{STM32 ARM Cortex Microcontrollers - 32-bit MCUs - STMicroelectonics}{http://www.st.com/en/microcontrollers/stm32-32-bit-arm-cortex-mcus.html}
  \bibitem{processor-sleep}
    \eresource{Advanced Sleep-Mode Techniques for Enhanced Battery Life in Real-Time Environments | DigiKey}{https://www.digikey.com/en/articles/techzone/2011/dec/advanced-sleep-mode-techniques-for-enhanced-battery-life-in-real-time-environments}
  \bibitem{hardware-is-cheap}
    \eresource{Hardware is Cheap, Programmers are Expensive}{https://blog.codinghorror.com/hardware-is-cheap-programmers-are-expensive/}
  \bibitem{misra}
    \eresource{MISRA - The Motor Industry Software Reliability Association}{https://www.misra.org.uk/}
  \bibitem{worst-practices-should-be-hard}
    \eresource{Haskell for all: Worst practices should be hard}{http://www.haskellforall.com/2016/04/worst-practices-should-be-hard.html}
  \bibitem{heartbleed}
    \eresource{Heartbleed Bug}{http://heartbleed.com/}
  \bibitem{blueborne}
    \eresource{Let's talk about Blueborne, the latest Bluetooth vulnerability}{https://www.androidcentral.com/lets-talk-about-blueborne-latest-bluetooth-vulnerability}
  \bibitem{oop-must-die}
    \eresource{Object Oriented Programming is an expensive disaster which must end | Smash Company}{http://www.smashcompany.com/technology/object-oriented-programming-is-an-expensive-disaster-which-must-end}

  \bibitem{an-empirical-study-of-operating-systems-errors}
    \eresource{An Empirical Study of Operating Systems Errors}{https://pdos.csail.mit.edu/archive/6.097/readings/osbugs.pdf}
  \bibitem{linux-kernel-developer-responses}
    \eresource{Linux Kernel Developer Responses to Static Analysis Bug Reports}{https://www.usenix.org/legacy/event/usenix09/tech/full_papers/guo/guo_html/index.html}
  \bibitem{40-variability-bugs}
    \eresource{40 Variability Bugs in the Linux Kernel. A Qualitative Study}{https://pure.itu.dk/ws/files/74775263/ITU_TR_2014_180.pdf}

\end{thebibliography}

% \appendix
% \chapter{}

\finalizepart{}

\end{document}
