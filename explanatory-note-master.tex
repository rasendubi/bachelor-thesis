\documentclass[main.tex]{subfiles}

\begin{document}

% \chapter{Технічне завдання для дипломного проекту}
% \section{Найменування і область застосування}
% \section{Підстави для розробки}
% \section{Мета і призначення розробки}
% \section{Джерела розробки}
% \section{Технічні вимоги}
% \subsection{Вимоги до розроблюваного продукту}
% \subsection{Вимоги до програмного забезпечення}
% \section{Етапи розробки}

\newpart{part3}{ІАЛЦ.467100.003 ПЗ}
\tableofcontents

% I'm not yet sure, I need a translation, so that may change in the
% future
\newcommand\engacro[3]{\acro{#1}{\acroextra{(}#2\acroextra{) #3}}}

\specialchapter{Список скорочень}
\begin{acronym}[EDSL]

  % To decrease spacing
  % \setlength\parskip{0ex}

  \engacro{AST}{Abstract Syntax Tree}{Абстрактне Синтаксичне Дерево}
  \engacro{DSL}{Domain-Specific Language}{Предметно-Орієнтована Мова}
  \engacro{EDSL}{Embedded Domain-Specific Language}{Вбудована Предметно-Орієнтована Мова}
  \acro{ELF}{Executable and Linkable Format}
  \engacro{LTO}{Link Time Optimization}{Оптимізація Часу Зв'язування}
  \engacro{RTOS}{Real-Time Operating System}{Операційна Система Реального Часу}
\end{acronym}

\specialchapter{Вступ}

Насьогодні, найбільш розповсюдженою мовою для програмування вбудованих систем, є мова C, яка відома своєю складністю застосування і високим ризиком допустится складних для відлагодження помилок. Найпоширенішим стандартом є C99, що був випущений у 1999 році. Це означає, що мова практично зупинила своє еволюційування і не отримувала значних покращешь напротязі 18 останніх років.

Мова C++, навпроти, активно розвивається і вийшла на регулярні оновлення кожні три роки. Але ця мова обмежена зворотньою сумісністю, що не дозволяє виправити більшість помилок, що були успадковані від мови C. Мову C++ складна у використанні, а також не має захисту від великого класу помилок.

Наразі, автору роботи не відома сучасна мова програмування, що повністю б задовольняла його потребам.

У рамках даного дипломного проекту ставиться завдання розробити мову програмування призначену для низькорівневого програмування: вбудованих систем, систем реального часу, операційних систем, системних утиліт. Мова має включати сучасні здобутки теорії мов програмування, бути продуктивною, швидкою і безпечною у використанні.

При створенні програмного продукту було пройдено повний цикл його написання -- від постановки завдання, написання технічного завдання і вимог до продукту, до написання програмного забезпечення та тестування.

\chapter{Огляд мов для низькорівневого програмування}

%\newcommand\LangC{Сі}
\newcommand\LangC{C}

\section{Загальні вимоги}

Програмування мікроконтролерів висуває певні вимоги до мови.

По-перше, мова має бути компілюєма, оскільки на дешевих мікроконтролерах дуже мало ресурсів для інтерпретації мови, або її компіляції. На більших платформах, інтерпретація можлива, але однаково вимагає додаткових витрат процесорного часу і пам'яті. Оскільки дана робота розглядає реалізацю операційної системи, що буде вимагати мінімального обсягу пам'яті, інтерпретація мови на мікроконтроллері неможлива.

По-друге, мова не повинна вимагати збирача сміття, або будь-якого іншої бібліотеки середовища виконання. Як і з інтерпретацією, це вимагає додаткових ресурсів, якими мікроконтролер часто не володіє.

По-третє, низькорівневе програмування схильне до програмних помилок, що важко знайти і виправити. На відміну від прикладного програмування, помилки на системному рівні частіше призводять до краху усієї системи. До найчастіших помилок можна віднести помилки виходу за границі буферу, помилки при роботі з динамічною пам'яттю, витік ресурсів, помилки синхронізації, виклик заборонених у певному контексті функцій. Це означає, що мови системного програмування мають приділяти особливу увагу питанню безпеки.

Також, для програмування операційних систем дуже важлива можливість контролювати розмітку пам'яті і робота з пам'яттю напряму. Додатковими плюсами є можливість вбудови асемблерних інструкцій, взаємодія з іншими мовами (зокрема мовою асемблера і \LangC{}), наявність якісного компілятора, що генерує швидкий код.

\section{C}

Мову \LangC{} було розроблено у 1972 році Денісом Рітчі у Bell Telephone Labaratories з метою написання операційної системи UNIX\cite{stewart-bill:history-of-c}. \LangC{} є однією із найпопулярніших у світі мов програмування за кількістю вже написаного програмного забезпечення, а також кількості програмістів.

Найпростіша програма мовою \LangC{} зображена на рисунку \ref{example:c}.

\begin{figure}[h]
  \centering
  \begin{BVerbatim}
#include <stdio.h>

// This is an example of comment
int main(void)
{
  printf("Hello, world!\n");

  return 0;
}
  \end{BVerbatim}
  \caption{Приклад найпростішої програми мовою \LangC{}}\label{example:c}
\end{figure}

Мова \LangC{} надає можливості прямого доступу до пам'яті, майже повний контроль над пам'яттю і потоком виконання, не має збирача сміття, або будь-якої бібліотеки середовища виконання. Також, \LangC{} має просту домовленість про виклики, що дозволяє легко використовуваи функції, написані на \LangC{}, майже з будь-якої іншої мови програмування, включаючи мову асемблера. Існують дуже потужні і стабільні компілятори, що генерують високоефективний машиний код. Все це робить \LangC{} гарним кандидатом.

Мова \LangC{} є \emph{де-факто} стандартом для написання вбудованих систем. Це перевірений роками інструмент, що довів свою ефективність і показав себе найкращим у класі вбудованих систем.

Однак, \LangC{} не можна назвати сучасною мовою. Її було розроблено майже 50 років тому і сьогодні не ведеться активних розробок з покращення і розвинення мови. Останній стандарт (C11) було випущено у 2011 році, але він вносить лише незначні покращення і не виправляє багатьох фундаментальних проблем мови \LangC{}.

Однією із серйозних проблем \LangC{} є типізація. Мова \LangC{} має слабку статичну типізацію; це означає, що всі типи перевіряються на етапі компіляції, але існують неявні приведення типу, що досить часто призводить до програмних помилок. Також, система типів є дуже примітивною, і не має корисних функцій, що характерні більш сучасним системам типів.

\section{Idris}\label{sec:idris}

Мова Idris\cite{idris} є чисто-функціональною мовою програмування з потужною системою типів, що підтримує залежні типи. Розробка мови ведеться з 2009 року\cite{idris:first-release}, тож мова є дуже молодою.

Код найпростішої програми мовою Idris наведено на рисунку \ref{example:idris}.

\begin{figure}[h]
  \centering
  \begin{BVerbatim}
module Main

main : IO ()
main = putStrLn "Hello, world!"
  \end{BVerbatim}
  \caption{Приклад найпростішої програми мовою Idris}\label{example:idris}
\end{figure}

Насьогодні, залежні типи не є широко-використовуваною технологією у програмуванні і використовуються здебільшого у науковому середовищі, а також ентузіастами мов програмування. Залежні типи стирають межу між типами і значеннями; типи стають звичайними значеннями, що дозволяє виконувати операції над типами, передавати їх як аргументи функцій і повертати їх із функцій. Тож можна мати різний тип в залежності від результатів обчислення певного значення, або іншого типу.

За допомогою залежних типів в Idris було побудовано систему ефектів. Система ефектів дозволяє розділити використання певних дій від їх конкретної реалізації. Наприклад, функція може використовувати функції логування, однак вибір їх конкретної реалізації залишається на функції, що врешті решт викличе виконання ефекту. Це можна назвати формою впровадження залежностей (dependency injection).

\begin{figure}%[h]
  \centering
  \begin{BVerbatim}
module Effect.File

import Effects
import Control.IOExcept

FILE_IO : Type -> EFFECT

data OpenFile : Mode -> Type

open : (fname : String)
       -> (m : Mode)
       -> Eff Bool [FILE_IO ()]
                   (\res => [FILE_IO
                     (case res of
                       True => OpenFile m
                       False => ())])
close : Eff () [FILE_IO (OpenFile m)] [FILE_IO ()]

readLine  : Eff String [FILE_IO (OpenFile Read)]
writeLine : String -> Eff () [FILE_IO (OpenFile Write)]
eof       : Eff Bool [FILE_IO (OpenFile Read)]

Handler FileIO IO where { ... }
  \end{BVerbatim}
  \caption{Приклад використання залежних типів}\label{idris:dependent-types}
\end{figure}

Система ефектів також дозволяє керувати і розмежовувати доступ повних функції до певних ефектів. Наприклад, можна створити ефект для роботи з мережею; тоді можна обмежувати доступ до мережевих операцій на рівні окремих функцій -- компілятор може гарантувати під час компіляції, що певна функція не буде використовувати функції роботи з мережею.

Система ефектів і залежні типи можуть підвищити рівень надійності операційних систем, якщо правильно їх використовувати. За допомогою створення окремого класу блокуючих операцій, можна позбавитися від цілого класу проблем, що виникають при виклику блокуючих операцій з обробнику переривань. За допомогою ще інакшого ефекту, можна гарантувати вивільнення ресурсів, як то пам'ять або відкриті файлові дескриптори. За допомогою залежних типів можна накладати обмеження на виділення оперативної пам'яті, або навіть на кількість тактів процесора для певних функцій. В цілому, залежні типи це дуже потужних механізм для забезпечення перевірки певних припущень у самомоу коді програми і математичного доведення правильності програми.

Нажаль, Idris вимагає збирача сміття і великої бібліотеки часу виконання, що унеможливлює використання Idris напряму для створення програмного забезпечення для систем з обмеженою пам'яттю. Але можливо створити EDSL (embedded domain-specific language, вбудована предметно-орієнтована мова) на базі Idris для генерація коду для вбудованих систем і таким чином позбутися даних обмежень мови. Схожим чином було реалізовано мови Atom\cite{haskell:atom} і Ivory\cite{haskell:ivory}, але на базі мови Haskell\cite{haskell}.

\section{Nim}

\begin{figure}[!bp]
  \centering
  \begin{BVerbatim}
# This is comment

# All top-level statements are
# executed when program starts
echo "Hello, world!"
  \end{BVerbatim}
  \caption{Приклад найпростішої програми мовою Nim}\label{example:nim}
\end{figure}

Мова Nim\cite{nim} (раніше Nimrod) вперше зв'явилася у 2008 році. Це багатопарадигмена мова, що компілюється у Javascript або \LangC{}, має сильну статичну типізацію і простий синтаксис. Nim має багаті можливості узагальненого (Generics), об'єктно-орієнтованого і шаблонного програмування. Особливо варто відмітити багаті можливості для обчислень під час компіляції. Макроси дозволяють змінювати AST (Abstract Syntax Tree, Абстрактне Синтаксиче Дерево) програми під час компіляції; за допомогою них можна як робити обчислення під час компіляції, так і змінювати синтаксис мови і розширювати його.

Nim також має спрощену систему ефектів. На відміну від системи ефектів в Idris, система ефектів в Nim дозволяє лише маркувати функції різними ефектами i відслітковувати їх. Цього достатньо для того, щоб уникнути програмних помилок пов'язаних з викликом функцій, що заборонені у даному контексті, однак, системи типів Nim не вистачає, щоб гарантувати вивільнення ресурсів, або робити більш складні речі з типами (наприклад, неможливо будувати докази).

Також, Nim має велику кількість директив компілятора\cite{nim:directives}, що можуть бути цікаві під час низькорівневого програмування. Однією із таких директив є прагма \code{effects}, яка і є вже оговореною системою ефектів. Також цікавою є пара прагм \code{guard} і \code{locks}, що дозволяють гарантувати використання промаркованих ресурсів у багатопотокових програмах використовуючи блокування. При цьому, Nim може гарантувати правильний порядок захоплення ресурсів за допомогою рівнів.

Nim має цілу низку директив компілятора, що дозволяють вставляти код написаний на мові \LangC{}, C++, або Objective-C. Це може бути дуже зручним, якщо необхідно багато взаємодіяти з іншими бібліотеками написаними на цих мовах.

За рахунок прагм Nim є дуже загальною мовою програмування, що можна використовувати для широкого спектру задач і середовищ. За допомогою директив компілятора можна контролювати передачу аргументів функцій (за значенням, за посиланням), можна вказувати підказки оптимізатору (розгортка циклів, вбудова викликів функцій, позначення для функцій, що не повертаються або не мають побічних ефектів), можна точно керувати схемою пам'яті (бітові поля, вирівнювання полів, генерація стек-фреймів), також збірник сміття є опціональним і його можна виключити за необхідності.

Нажаль, під час більш детального аналізу було виявлено серйозний недолік в реалізації компілятора. Прагму \code{volatile} було реалізовано некоректно\cite{nim:volatile}, що унеможливило нормальне використання мови для низькорівневого програмування.

\section{Rust}

Rust\cite{rust} це молода багатопарадигмена компілюєма мова для системного програмування, що активно розвивається. Мова вперше з'явилася у 2010 році і була розроблена компанією Mozilla\cite{rust:mozilla}. Мова націлена на безпечне і багатопотокове програмування і має низку особливостей, що цьому допомагають.

\begin{figure}[h]
  \centering
  \begin{BVerbatim}
// This is a comment.

// This is the main function
fn main() {

  // Print text to the console
  println!("Hello, world!");
}
  \end{BVerbatim}
  \caption{Приклад найпростішої програми мовою Rust}\label{example:rust}
\end{figure}

Основною функціональною особливістю мови є потужна система типів. Типізацію у Rust є статичною і сильною, що дозволяє уникнути широкого класу помилок зумовлених неявним приведенням типів. Система типів у Rust також є лінійною; це характеристика, що дозволяє уникати помилок розділення ресурсів у багатопотоковому програмуванні за допомогою системи типів (без блокування). Система типів у Rust дозволяє мати лише одне посилання на об'єкт, за яким можна змінювати його, або безліч посилань, за якими можна лише зчитувати дані. Неможливо одночасно мати два посилання на об'єкт, що дозволяють зчитувати і змінювати дані. Це дозволяє уникнути багатьох помилок у багатопотоковому програмуванні уже під час компіляції, без будь-яких витрат під час роботи.

Також, Rust має чітке розмежування між так званими безпечним і небезпечним рівнями. У безпечному рівні заборонено використання певних операцій, що можуть призвести до помилок (наприклад, заборонено використання звичайних вказівників на пам'ять). Це дозволяє мові забезпечити певні гарантії. За замовчуванням, функції є безпечними, а для використання небезпечних операцій необхідно позначити функцію або блок коду як небезпечний. Це дозволяє локалізувати код, що може викликати проблеми.

Інує реалізація простої системи ефектів у вигляді бібліотеки.

Rust також надає багато можливостей, що необхідні для низькорівневого програмування: точне керування схемою пам'яті, гарну взаємодію з мовою \LangC{}, відсутність збірника сміття і бібліотеки часу виконання. Компілятор Rust використовує LLVM\cite{llvm} для компіляції, що дозволяє йому генерувати ефективний код для великої кількості платформ.

Rust також має синтаксис дуже схожий до мови \LangC{}, що є плюсом для широкого розповсюдження мови, оскільки даний синтаксис є відомим багатьом програмістам.

\chapterconslusions{}

Мова \LangC{} є гарним вибором для комерційного проекту, але не надає ніяких технічних переваг. Використання даної мови не несе собою новизни і не цікаве з точки зору дослідження.

Idris має одну із найпотужніших систем типів насьогодні. Її особливості можна було б використати для створення значно більш надійних операційних систем. Нажаль, Idris вимагає збирача сміття і великої бібліотеки середовища виконання. Це унеможливлює використання Idris для операційних систем для вбудованих пристроїв напряму. Розробка EDSL на Idris може бути виходом, але вимає додаткових затрат.

Nim є дуже цікавою мовою, що має опціональний збиральник сміття і може працювати без бібліотеки середовища виконання. Вона має багато особливостей, що можуть допомогти при написанні низькорівневого програмного забезпечення. Однак, низька якість реалізації компілятора майже унеможливлює використання мови для більш-менш серйозного низькорівневого програмування.

Система типів Rust є гарним компромісом між потужною системою типів Idris, яка вимагає певної підтримки від середовища виконання, і системи типів \LangC{}, що не потребує середовища виконання, але є занадто простою. За допомогою типів, Rust допомагає гарантовано уникнути певного класу помилок, що є розповсюдженими при низькорівневому програмуванні. Також, розділення на безпечні і небезпечні операції дозволяє локалізувати код, що може викликати програмні помилки.

\begin{thebibliography}{00}
  \bibitem{stewart-bill:history-of-c}
    \eresource{History of C Programming Language}{http://www.livinginternet.com/i/iw\_unix\_c.htm}

  \bibitem{idris}
    \eresource{Idris | A Language with Dependent Types}{http://www.idris-lang.org/}
  \bibitem{idris:first-release}
    \eresource{idris: Dependently Typed Functional Programming Language}{http://hackage.haskell.org/package/idris-0.1.3}
  \bibitem{haskell:atom}
    \eresource{atom: An EDSL for embedded hard realtime applications}{https://hackage.haskell.org/package/atom}
  \bibitem{haskell:ivory}
    \eresource{Ivory - index}{http://ivorylang.org/index.html}
  \bibitem{haskell}
    \eresource{Haskell Language}{https://www.haskell.org/}

  \bibitem{nim}
    \eresource{Nim Programming Language}{http://nim-lang.org/}
  \bibitem{nim:directives}
    \eresource{Nim Manual}{http://nim-lang.org/docs/manual.html\#pragmas}
  \bibitem{nim:volatile}
    \eresource{\{.volatile.\} is almost useless · Issue \# 3382 · nim-lang/Nim}{https://github.com/nim-lang/Nim/issues/3382}

  \bibitem{rust}
    \eresource{The Rust Programming Language}{https://www.rust-lang.org/}
  \bibitem{rust:mozilla}
    \eresource{The Rust Language | Lambda the Ultimate}{http://lambda-the-ultimate.org/node/4009}
  \bibitem{llvm}
    \eresource{The LLVM Compiler Infrastructure Project}{http://llvm.org/}

\end{thebibliography}

% \appendix
% \chapter{}

\finalizepart{}

\end{document}
