\documentclass[main.tex]{subfiles}

\usemintedstyle{bw}

\begin{document}

\newpart{part3}{ІАЛЦ.467100.003 ПЗ}
\tableofcontents

% I'm not yet sure I need a translation, so that may change in the
% future
\newcommand\engacro[3]{\acro{#1}{\acroextra{(}#2\acroextra{) #3}}}

\specialchapter{Список скорочень}
\begin{acronym}[MMMM]

  % To decrease spacing
  % \setlength\parskip{0ex}

  \engacro{ADT}{Algebraic Data Type}{Алегбраїчний Тип Даних}
  \engacro{AST}{Abstract Syntax Tree}{Абстрактне Синтаксичне Дерево}
  \engacro{DSL}{Domain-Specific Language}{Предметно-Орієнтована Мова}
  \engacro{EDSL}{Embedded Domain-Specific Language}{Вбудована Предметно-Орієнтована Мова}
  \acro{ELF}{Executable and Linkable Format}
  \engacro{FFI}{Foreign Function Interface}{Інтерфейс Зовнішньої Функції}
  \engacro{GADT}{Generalized Algebraic Data Type}{Узагальнений Алгебраїчний Тип Даних}
  \engacro{LTO}{Link Time Optimization}{Оптимізація Часу Зв'язування}
  \engacro{RAII}{Resource Acquisition Is Initialization}{Отримання ресурсу є ініціалізація}
  \engacro{RTOS}{Real-Time Operating System}{Операційна Система Реального Часу}
  \engacro{TCO}{Tail Call Optimization}{Оптимізація хвостових викликів}
  \acro{ООП}{Об'єкто-Орієнтоване Програмування}
\end{acronym}

\specialchapter{Вступ}

Насьогодні, найбільш розповсюдженою мовою для програмування вбудованих систем, є мова C, яка відома своєю складністю застосування і високим ризиком допустится складних для відлагодження помилок. Найпоширенішим стандартом є C99, що був випущений у 1999 році. Це означає, що мова практично зупинила своє еволюційування і не отримувала значних покращешь напротязі 18 останніх років.

Мова C++, навпроти, активно розвивається і вийшла на регулярні оновлення кожні три роки. Але ця мова обмежена зворотньою сумісністю, що не дозволяє виправити більшість помилок, що були успадковані від мови C. Мову C++ складна у використанні, а також не має захисту від великого класу помилок.

Наразі, автору роботи не відома сучасна мова програмування, що повністю б задовольняла його потребам.

У рамках даного дипломного проекту ставиться завдання розробити мову програмування призначену для низькорівневого програмування: вбудованих систем, систем реального часу, операційних систем, системних утиліт. Мова має включати сучасні здобутки теорії мов програмування, бути продуктивною, швидкою і безпечною у використанні.

При створенні програмного продукту було пройдено повний цикл його написання --- від постановки завдання, написання технічного завдання і вимог до продукту, до написання програмного забезпечення та тестування.

\chapter{Огляд мов низькорівневого програмування}

%\newcommand\LangC{Сі}
\newcommand\LangC{C}

\section{Загальні вимоги}

Програмування мікроконтролерів висуває певні вимоги до мови.

По-перше, мова має бути компілюєма, оскільки на дешевих мікроконтролерах дуже мало ресурсів для інтерпретації мови, або її компіляції. На більших платформах, інтерпретація можлива, але однаково вимагає додаткових витрат процесорного часу і пам'яті. Оскільки дана робота розглядає реалізацю операційної системи, що буде вимагати мінімального обсягу пам'яті, інтерпретація мови на мікроконтроллері неможлива.

По-друге, мова не повинна вимагати збирача сміття, або будь-якого іншої бібліотеки середовища виконання. Як і з інтерпретацією, це вимагає додаткових ресурсів, якими мікроконтролер часто не володіє.

По-третє, низькорівневе програмування схильне до програмних помилок, що важко знайти і виправити. На відміну від прикладного програмування, помилки на системному рівні частіше призводять до краху усієї системи. До найчастіших помилок можна віднести помилки виходу за границі буферу, помилки при роботі з динамічною пам'яттю, витік ресурсів, помилки синхронізації, виклик заборонених у певному контексті функцій. Це означає, що мови системного програмування мають приділяти особливу увагу питанню безпеки.

Також, для програмування операційних систем дуже важлива можливість контролювати розмітку пам'яті і робота з пам'яттю напряму. Додатковими плюсами є можливість вбудови асемблерних інструкцій, взаємодія з іншими мовами (зокрема мовою асемблера і \LangC{}), наявність якісного компілятора, що генерує швидкий код.

\section{C}

Мову \LangC{} було розроблено у 1972 році Денісом Рітчі у Bell Telephone Labaratories з метою написання операційної системи UNIX\cite{stewart-bill:history-of-c}. \LangC{} є однією із найпопулярніших у світі мов програмування за кількістю вже написаного програмного забезпечення, а також кількості програмістів.

Найпростіша програма мовою \LangC{} зображена на рисунку \ref{example:c}.

\begin{figure}[h]
  \centering
  \begin{minted}{c}
#include <stdio.h>

// This is an example of comment
int main(void)
{
  printf("Hello, world!\n");

  return 0;
}
  \end{minted}
  \caption{Приклад найпростішої програми мовою \LangC{}}
  \label{example:c}
\end{figure}

Мова \LangC{} надає можливості прямого доступу до пам'яті, майже повний контроль над пам'яттю і потоком виконання, не має збирача сміття, або будь-якої бібліотеки середовища виконання. Також, \LangC{} має просту домовленість про виклики, що дозволяє легко використовуваи функції, написані на \LangC{}, майже з будь-якої іншої мови програмування, включаючи мову асемблера. Існують дуже потужні і стабільні компілятори, що генерують високоефективний машиний код. Все це робить \LangC{} гарним кандидатом.

Мова \LangC{} є \emph{де-факто} стандартом для написання вбудованих систем. Це перевірений роками інструмент, що довів свою ефективність і показав себе найкращим у класі вбудованих систем.

Однак, \LangC{} не можна назвати сучасною мовою. Її було розроблено майже 50 років тому і сьогодні не ведеться активних розробок з покращення і розвинення мови. Останній стандарт (C11) було випущено у 2011 році, але він вносить лише незначні покращення і не виправляє багатьох фундаментальних проблем мови \LangC{}.

Однією із серйозних проблем \LangC{} є типізація. Мова \LangC{} має слабку статичну типізацію; це означає, що всі типи перевіряються на етапі компіляції, але існують неявні приведення типу, що досить часто призводить до програмних помилок. Також, система типів є дуже примітивною, і не має корисних функцій, що характерні більш сучасним системам типів.

\section{Idris}\label{sec:idris}

Мова Idris\cite{idris} є чисто-функціональною мовою програмування з потужною системою типів, що підтримує залежні типи. Розробка мови ведеться з 2009 року\cite{idris:first-release}, тож мова є дуже молодою.

Код найпростішої програми мовою Idris наведено на рисунку \ref{example:idris}.

\begin{figure}[h]
  \centering
  \begin{minted}{idris}
module Main

main : IO ()
main = putStrLn "Hello, world!"
  \end{minted}
  \caption{Приклад найпростішої програми мовою Idris}
  \label{example:idris}
\end{figure}

Насьогодні, залежні типи не є широко-використовуваною технологією у програмуванні і використовуються здебільшого у науковому середовищі, а також ентузіастами мов програмування. Залежні типи стирають межу між типами і значеннями; типи стають звичайними значеннями, що дозволяє виконувати операції над типами, передавати їх як аргументи функцій і повертати їх із функцій. Тож можна мати різний тип в залежності від результатів обчислення певного значення, або іншого типу.

За допомогою залежних типів в Idris було побудовано систему ефектів. Система ефектів дозволяє розділити використання певних дій від їх конкретної реалізації. Наприклад, функція може використовувати функції логування, однак вибір їх конкретної реалізації залишається на функції, що врешті решт викличе виконання ефекту. Це можна назвати формою впровадження залежностей (dependency injection).

\begin{figure}%[h]
  \centering
  \begin{minted}{idris}
module Effect.File

import Effects
import Control.IOExcept

FILE_IO : Type -> EFFECT

data OpenFile : Mode -> Type

open : (fname : String)
       -> (m : Mode)
       -> Eff Bool [FILE_IO ()]
                   (\res => [FILE_IO
                     (case res of
                       True => OpenFile m
                       False => ())])
close : Eff () [FILE_IO (OpenFile m)] [FILE_IO ()]

readLine  : Eff String [FILE_IO (OpenFile Read)]
writeLine : String -> Eff () [FILE_IO (OpenFile Write)]
eof       : Eff Bool [FILE_IO (OpenFile Read)]

Handler FileIO IO where { ... }
  \end{minted}
  \caption{Приклад використання залежних типів}
  \label{idris:dependent-types}
\end{figure}

Система ефектів також дозволяє керувати і розмежовувати доступ повних функції до певних ефектів. Наприклад, можна створити ефект для роботи з мережею; тоді можна обмежувати доступ до мережевих операцій на рівні окремих функцій -- компілятор може гарантувати під час компіляції, що певна функція не буде використовувати функції роботи з мережею.

Система ефектів і залежні типи можуть підвищити рівень надійності операційних систем, якщо правильно їх використовувати. За допомогою створення окремого класу блокуючих операцій, можна позбавитися від цілого класу проблем, що виникають при виклику блокуючих операцій з обробнику переривань. За допомогою ще інакшого ефекту, можна гарантувати вивільнення ресурсів, як то пам'ять або відкриті файлові дескриптори. За допомогою залежних типів можна накладати обмеження на виділення оперативної пам'яті, або навіть на кількість тактів процесора для певних функцій. В цілому, залежні типи це дуже потужних механізм для забезпечення перевірки певних припущень у самомоу коді програми і математичного доведення правильності програми.

Нажаль, Idris вимагає збирача сміття і великої бібліотеки часу виконання, що унеможливлює використання Idris напряму для створення програмного забезпечення для систем з обмеженою пам'яттю. Але можливо створити EDSL (embedded domain-specific language, вбудована предметно-орієнтована мова) на базі Idris для генерація коду для вбудованих систем і таким чином позбутися даних обмежень мови. Схожим чином було реалізовано мови Atom\cite{haskell:atom} і Ivory\cite{haskell:ivory}, але на базі мови Haskell\cite{haskell}.

\section{Nim}

\begin{figure}[!bp]
  \centering
  \begin{minted}{nim}
# This is comment

# All top-level statements are
# executed when program starts
echo "Hello, world!"
  \end{minted}
  \caption{Приклад найпростішої програми мовою Nim}
  \label{example:nim}
\end{figure}

Мова Nim\cite{nim} (раніше Nimrod) вперше зв'явилася у 2008 році. Це багатопарадигмена мова, що компілюється у Javascript або \LangC{}, має сильну статичну типізацію і простий синтаксис. Nim має багаті можливості узагальненого (Generics), об'єктно-орієнтованого і шаблонного програмування. Особливо варто відмітити багаті можливості для обчислень під час компіляції. Макроси дозволяють змінювати AST (Abstract Syntax Tree, Абстрактне Синтаксиче Дерево) програми під час компіляції; за допомогою них можна як робити обчислення під час компіляції, так і змінювати синтаксис мови і розширювати його.

Nim також має спрощену систему ефектів. На відміну від системи ефектів в Idris, система ефектів в Nim дозволяє лише маркувати функції різними ефектами i відслітковувати їх. Цього достатньо для того, щоб уникнути програмних помилок пов'язаних з викликом функцій, що заборонені у даному контексті, однак, системи типів Nim не вистачає, щоб гарантувати вивільнення ресурсів, або робити більш складні речі з типами (наприклад, неможливо будувати докази).

Також, Nim має велику кількість директив компілятора\cite{nim:directives}, що можуть бути цікаві під час низькорівневого програмування. Однією із таких директив є прагма \code{effects}, яка і є вже оговореною системою ефектів. Також цікавою є пара прагм \code{guard} і \code{locks}, що дозволяють гарантувати використання промаркованих ресурсів у багатопотокових програмах використовуючи блокування. При цьому, Nim може гарантувати правильний порядок захоплення ресурсів за допомогою рівнів.

Nim має цілу низку директив компілятора, що дозволяють вставляти код написаний на мові \LangC{}, C++, або Objective-C. Це може бути дуже зручним, якщо необхідно багато взаємодіяти з іншими бібліотеками написаними на цих мовах.

За рахунок прагм Nim є дуже загальною мовою програмування, що можна використовувати для широкого спектру задач і середовищ. За допомогою директив компілятора можна контролювати передачу аргументів функцій (за значенням, за посиланням), можна вказувати підказки оптимізатору (розгортка циклів, вбудова викликів функцій, позначення для функцій, що не повертаються або не мають побічних ефектів), можна точно керувати схемою пам'яті (бітові поля, вирівнювання полів, генерація стек-фреймів), також збірник сміття є опціональним і його можна виключити за необхідності.

Нажаль, під час більш детального аналізу було виявлено серйозний недолік в реалізації компілятора. Прагму \code{volatile} було реалізовано некоректно\cite{nim:volatile}, що унеможливило нормальне використання мови для низькорівневого програмування.

\section{Rust}

Rust\cite{rust} це молода багатопарадигмена компілюєма мова для системного програмування, що активно розвивається. Мова вперше з'явилася у 2010 році і була розроблена компанією Mozilla\cite{rust:mozilla}. Мова націлена на безпечне і багатопотокове програмування і має низку особливостей, що цьому допомагають.

\begin{figure}[h]
  \centering
  \begin{minted}{rust}
// This is a comment.

// This is the main function
fn main() {

  // Print text to the console
  println!("Hello, world!");
}
  \end{minted}
  \caption{Приклад найпростішої програми мовою Rust}
  \label{example:rust}
\end{figure}

Основною функціональною особливістю мови є потужна система типів. Типізацію у Rust є статичною і сильною, що дозволяє уникнути широкого класу помилок зумовлених неявним приведенням типів. Система типів у Rust також є лінійною; це характеристика, що дозволяє уникати помилок розділення ресурсів у багатопотоковому програмуванні за допомогою системи типів (без блокування). Система типів у Rust дозволяє мати лише одне посилання на об'єкт, за яким можна змінювати його, або безліч посилань, за якими можна лише зчитувати дані. Неможливо одночасно мати два посилання на об'єкт, що дозволяють зчитувати і змінювати дані. Це дозволяє уникнути багатьох помилок у багатопотоковому програмуванні уже під час компіляції, без будь-яких витрат під час роботи.

Також, Rust має чітке розмежування між так званими безпечним і небезпечним рівнями. У безпечному рівні заборонено використання певних операцій, що можуть призвести до помилок (наприклад, заборонено використання звичайних вказівників на пам'ять). Це дозволяє мові забезпечити певні гарантії. За замовчуванням, функції є безпечними, а для використання небезпечних операцій необхідно позначити функцію або блок коду як небезпечний. Це дозволяє локалізувати код, що може викликати проблеми.

Інує реалізація простої системи ефектів у вигляді бібліотеки.

Rust також надає багато можливостей, що необхідні для низькорівневого програмування: точне керування схемою пам'яті, гарну взаємодію з мовою \LangC{}, відсутність збірника сміття і бібліотеки часу виконання. Компілятор Rust використовує LLVM\cite{llvm} для компіляції, що дозволяє йому генерувати ефективний код для великої кількості платформ.

Rust також має синтаксис дуже схожий до мови \LangC{}, що є плюсом для широкого розповсюдження мови, оскільки даний синтаксис є відомим багатьом програмістам.

\chapterconslusions{}

Мова \LangC{} є гарним вибором для комерційного проекту, але не надає ніяких технічних переваг. Використання даної мови не несе собою новизни і не цікаве з точки зору дослідження.

Idris має одну із найпотужніших систем типів насьогодні. Її особливості можна було б використати для створення значно більш надійних операційних систем. Нажаль, Idris вимагає збирача сміття і великої бібліотеки середовища виконання. Це унеможливлює використання Idris для операційних систем для вбудованих пристроїв напряму. Розробка EDSL на Idris може бути виходом, але вимає додаткових затрат.

Nim є дуже цікавою мовою, що має опціональний збиральник сміття і може працювати без бібліотеки середовища виконання. Вона має багато особливостей, що можуть допомогти при написанні низькорівневого програмного забезпечення. Однак, низька якість реалізації компілятора майже унеможливлює використання мови для більш-менш серйозного низькорівневого програмування.

Система типів Rust є гарним компромісом між потужною системою типів Idris, яка вимагає певної підтримки від середовища виконання, і системи типів \LangC{}, що не потребує середовища виконання, але є занадто простою. За допомогою типів, Rust допомагає гарантовано уникнути певного класу помилок, що є розповсюдженими при низькорівневому програмуванні. Також, розділення на безпечні і небезпечні операції дозволяє локалізувати код, що може викликати програмні помилки.

\chapter{Проектування мови}
\section{Аналіз середовища і обмежень}
Програмування для вбудованих систем накладає досить велику кількість обмежень і висуває багато специфічних вимог до мови --- саме через це існує дуже мало мов програмування, що можуть бути використані для даних цілей.
Саме тому, для початку проектування мови, необхідно визначити основні обмеження і вимоги.

Розглянемо особливості оточення на прикладі мікроконтроллерів ARM серії Cortex-M\cite{cortex-m} і їх реалізації від STMicroelectonics\cite{cortex-m:stm}. Мікроконтроллери серії Cortex-M це сімейство глибоко вбудованих процесорів, оптимізованих для застосувань, що чутливі до витрат.

\newcommand\elfsection[1]{\texttt{#1}}

\begin{itemize}[nosep]
\item \textbf{Низький об'єм RAM}. Об'єми оперативної пам'яті складають від 2 Кілобайт до 1 Мегабайта. Типові об'ями оперативної пам'яті, з якими доводилося працювати автору --- 16--256 Кілобайт. Оперативна пам'ять включає в себе \elfsection{.data} і \elfsection{.bss} секції; гарною новиною є те, що секція \elfsection{.code} не входить в даний об'єм, оскільки процесор виконує програминй код з ROM без завантаження в оперативну пам'ять.

\item \textbf{Низький об'єм ROM}. Об'єми вбудованої флеш пам'яті варіюються від 8 Кілобайт до 2 Мегабайт. Типовими є розміри до 1 Мегабайту. Через особливості завантаження прошивки, до складу ROM входять наступні секції: \elfsection{.text} (код), \elfsection{.rodata} (константи доступні лише для читання), \emph{а також} \elfsection{.data} (ненульові початкові значення для статичних змінних), що уже була включена до об'єму RAM.

\item \textbf{Обмежене живлення}. Багато вбудованих систем живляться від батарей, що означає, що програмісти мають перейматися питаннями збереження енергії, включаючи утримання процесора в режимі сну більшість часу (буквально, більше 99\% всього часу\cite{processor-sleep}).

\item \textbf{Програмісти дешеві; апаратне забезпечення дороге}. На відміну від більшості інших областей програмування\cite{hardware-is-cheap}, додавання потужності апаратного забезпечення означає, що ціна продукту збільшується для \emph{всіх} кінцевих користувачів. Тому, зазвичай, дешевше використати додатковий час програмістів для оптимізації коду, аніж обрати більш потужний чип. Також, потужніші процесори споживають більше енергії, що означає збільшення об'єму батарей, що збільшує ціну ще більше (не кажучи про збільшеня розмірів пристрою).

\item \textbf{Передбачуваність}. Багато вбудованих систем мають м'які або жорсткі вимоги реального часу. Це означає, що система забов'язана забезпечити відповідь в обмежених часових рамках. На практиці, це означає, що використання багатьох планувальників, збірників сміття, алокаторів пам'яті, або навіть виключень заборонене.

\item \textbf{Безпечність}. Система має бути надійною, оскільки в інакшому випадку можуть загинути люди. З цієї причини існує багато стандартів, таких як MISRA\cite{misra}, що вимагають дотримання певної дисципліни і дуже часто забороняють використання певних можливостей мови.

\item \textbf{Відлагодження програмних помилок важке}. Зазвичай, вбудовані пристрої не мають засобів для захисту від некоректного використання пам'яті, через що багато помилок проявляються в абсолютно не пов'язаних частинах системи, через деякий час, без трасування стеку і будь-яких підказок. Через це, відлагодження помилок у вбудованих системах є ще довшим і дорожчим, ніж в інших областях програмування.

\item \textbf{Компіляція без середовища виконання}. Мова забов'язана компілюватися.

\begin{enumerate}[nosep]
\item Процесори просто не мають ресурсів для JIT-компілятора або іншого середовища виконання.
\item JIT компіляція погіршує передбачуваність, оскільки час компіляції і паузи здебільшого важко піддаються передбаченню.
\item JIT практично вимагає виконання коду з оперативної пам'яті. Не беручи до уваги обмежену кількість оперативної пам'яті, виконання коду з оперативної пам'яті погіршує продуктивність, оскільки процесори ARM мають виділену лінію для витягування коду з флеш-пам'яті.
\end{enumerate}

Необхідно зазначити, що мова може підтримувати декілька форм виконання. Наприклад, вона може одночасно підтримувати компіляцію в машиний код, код віртуальної машини JVM, JavaScript, а також Vimscript, Lisp, і Whitespace.

З тих самих причин (обмежена кількість оперативної пам'яті), мова не має містити збірника сміття (або принаймні робити його опціональним).
\end{itemize}

\section{Основні цілі і принципи мови}
Для того, щоб спроектувати мову, необхідно сфокусувати свою увагу на найбільш суттєвих характеристиках, визначитися з основними цілями, напрямками і принципами мови.

Головним фокусом розроблюваної мови є зменшення кількості програмних помилок, що допускають програмісти.

Зменшення кількості помилок означає зменшення часу затраченого на відлагодження програм, підвищення надійності, а також зменшення кількості потенційних дір у безпеці.
Однак, не можна нехтувати продуктивністю і іншими критичними для системного програмування характеристиками.

Далі наведено список основних принципів, якими необхідно керуватися при розробці мови.

\subsection{Безпечність}
Мова має запобігати і унеможливлювати максимально велику кількість типових помилок, що допускають програмісти. Але при цьому, мова на має обмежувати можливості програміста і має дозволяти йому реалізувати будь-який функціонал.

\subsection{Простота і явність}
Прості мови набагато легше зрозуміти і розмірковувати про них, що призводить до зменшення кількості програмних помилок. Явність робить мову більш простою і передбачуваною.

Яскравим контр-прикладом є мова C++, яка має велику кількість правил, неочевидних виключень і славиться своєю складністю.

Розроблювана мова має бути максимально ``прозорою'' і очевидною для програміста. Це означає, що мова має бути ``простою'': містити мало виключень з правил, а також виконувати мінімальну кількість неявних дій. Передбачувані мови мінімізують шанс неправильної інтерпретації людиною, що зменшує кількість неочікуваної поведінки, що, зазвичай, призводить до програмних помилок.

\subsection{Продуктивність}
Мова має мінімізувати накладні витрати на забезпечення безпеки. Швидкодія програм, написаних на розроблюваній мові, має бути порівнювана з аналогічними програмами написаними на мові \LangC{}.
За можливості, перевага надається абстраціям з нульовою вартістю.

%\subsection{Сучасність}
%Розроблювана мова має надавати сучасні можливості для створення абстракцій.
%Мова має включати \todo{write this section}

\subsection{Найгірші практики повинні бути важкими}
Є велика різниця між ``підтримується мовою'' і ``заохочується мовою''.

Гарним прикладом є константні змінні. І \LangC{}, і Rust підтримують константність змінних, але константи в Rust є більш поширеними. Причиною цього є те, що в мові Rust всі змінні константні за замовчуванням, а для неконстантних змінних вимагається додаткове слово (\code{let} проти \code{let mut}). Тому програмісти використовують константи, окрім випадків, коли змінність необхідна. (Окрім того, компілятор Rust видає діагностичне повідомлення, якщо неконстантна змінна ніколи не змінювалася). З іншого боку, мова \LangC{} навпаки вимагає введення додаткового слова \code{const}, що призводить до того, що більшість змінних є неконстантними, навіть якщо цього не потребується.

%\cite{worst-practices-should-be-hard}

\section{Аналіз типових помилок}
Для того, щоб ефективно запобігати помилкам, необхідно більш детально дослідити їх.

\FloatBarrier
\subsection{Аналіз 1}\label{errors:os}
В рамках секції \ref{errors:os} розглядаються результати наукової статті ``An Empirical Study of Operating Systems Errors''\cite{an-empirical-study-of-operating-systems-errors}.

Згідно до статті, найрозповсюдженіші помилки наведено у тaблиці \ref{linux-errors}.
Більшість даних помилок можна обмежити засобами мови. Таблиця \ref{linux-errors-mitigation} підсумовує можливі варіанти.

\begin{table}
  \tabulinesep=1mm
  \begin{tabu}{|c|c|X[l]|}
    \hline
    Check & Nbugs & Rule checked \\
    \hline
    \code{Block} & 206 + 87 & To avoid deadlock, do not call blocking functions with interrupts disabled or a spinlock held. \\
    \code{Null} & 124 + 267 & Check potentially NULL pointers returned from routines. \\
    \code{Var} & 33 + 69 & Do not allocate large stack variables (> 1K) on the fixed-size kernel stack. \\
    \hline
    \code{Inull} & 69 & Do not make inconsistent assumptions about whether a pointer is \code{NULL}. \\
    \code{Range} & 54 & Always check bounds of array indices and loop bounds derived from user data. \\
    \code{Lock} & 26 & Release acquired locks; do not double-acquire locks. \\
    \code{Intr} & 27 & Restore disabled interrupts. \\
    \code{Free} & 17 & Do not use freed memory. \\
    \hline
    \code{Float} & 10 + 15 & Do not use floating point in the kernel. \\
    \code{Real} & 10 + 1 & Do not leak memory by updating pointers with potentially \code{NULL} realloc return values. \\
    \code{Param} & 7 & Do not dereference user pointers. \\
    \code{Size} & 3 & Allocate enough memory to hold the type for which you are allocating. \\
    \hline
  \end{tabu}
  \caption{Найрозповсюдженіші помилки у ядрі Linux}
  \label{linux-errors}
\end{table}

\begin{table}
  \tabulinesep=1mm
  \begin{tabu}{|c|X[l]|}
    \hline
    Перевірка & Засоби попередження \\
    \hline
    \code{Block} & Система ефектів \\
    \code{Null} & Використання посилань замість вказівників \\
    \code{Var} & Розрахунок максимального розміру стеку, модифікована система ефектів \\
    \hline
    \code{Inull} & Система ефектів, використання вказівників \\
    \code{Range} & Автоматична перевірка границь, залежні типі, система ефектів, liquid типи \\
    \code{Lock} & Деструктори (RAII) \\
    \code{Intr} & Деструктори (RAII) \\
    \code{Free} & Лінійна система типів, RAII \\
    \hline
    \code{Float} & Система ефектів \\
    \code{Real} & Дизайн правильних інтерфейсів і абстракцій \\
    \code{Param} & Система ефектів застосована до зміних, легкі обгортки навколо інших типів \\
    \code{Size} & Дизайн правильних інтерфейсів \\
    \hline
  \end{tabu}
  \caption{Засоби мови, що можуть запобігти помилкам}
  \label{linux-errors-mitigation}
\end{table}

\FloatBarrier
\subsection{Аналіз 2}\label{linux-kernel-developer-responses-section}
Секція \ref{linux-kernel-developer-responses-section} аналізує дані про розповсюдженість помилок, що були зібрані в рамках дослідження ``Linux Kernel Developer Responses to Static Analysis Bug Reports''\cite{linux-kernel-developer-responses}.

Зазначене дослідження наводить наступні типи помилок:
\begin{enumerate}[nosep]
\item dynamic buffer overrun
\item read of uninitialized values
\item dead code
\item static buffer overrun
\item unsafe use before negative test
\item type/allocation size mismatch
\item unsafe use before null test
\item resource leak
\item null pointer dereference
\item unsafe use of null return value
\item use resource after free
\item unsafe use of negative return value
\end{enumerate}

\FloatBarrier
\subsection{Аналіз 3}\label{errors:variability}
Секція \ref{errors:variability} аналізує дані про розповсюдженість помилок, що були зібрані в рамках дослідження ``40 Variability Bugs in the Linux Kernel. A Qualitative Study''\cite{40-variability-bugs}.

Таблиця \ref{variability-errors} підсумовує помилки виявлені в межах дослідження разом зі шляхами їх уникнення на рівні мови.

\begin{table}
  \tabulinesep=1mm
  \begin{tabu}{|c|l|X[l]|}
    \hline
    Частота & Тип помилки & Спосіб уникнення \\
    \hline\hline
    15 & Memory errors: & \\
    4 & null pointer dereference & Використання посилань \\
    3 & buffer overflow & Автоматична перевірка границь, залежні типи, liquid типи \\
    3 & read out of bounds & Автоматична перевірка границь, залежні типи, liquid типи \\
    2 & insufficient memory & \\
    1 & memory leak & RAII \\
    1 & use after free & RAII, лінійна система типів \\
    1 & write on read only & Посилання, що доступні лише для читання \\
    \hline
    8 & Compiler warnings: & \\
    5 & uninitialized variable & Попередження компілятора, вимога ініціалізації змінних \\
    1 & unused function (dead code) & Попередження компілятора \\
    1 & unused variable & Попередження компілятора \\
    1 & void pointer dereference & Строга система типів \\
    \hline
    7 & Type errors: & \\
    5 & undefined symbol & Перевірка компілятора \\
    1 & undeclared identifier & Перевірка компілятора \\
    1 & wrong number of args to function & Перевірка компілятора \\
    \hline
    7 & Assertion violations: & \\
    5 & fatal assertion violation & \\
    2 & non-fatal assertion violation & \\
    \hline
    2 & API violations: & \\
    1 & Linux sysfs API violation & Більш потужні засоби для забезпечення дотримання інтерфейсів \\
    1 & double lock & Лінійна система типів \\
    \hline
    1 & Arithmetic errors: & \\
    1 & numeric truncation & Заборона неявних преведень типів, автоматична перевірка переповнень \\
    \hline
  \end{tabu}
  \caption{Часті помилки і способи їх уникнення}
  \label{variability-errors}
\end{table}

\FloatBarrier
\section{Дизайн}

\subsection{Сімейство синтаксису}
Окрім широко-відомого C-подібного сімейства синтаксису, існує досить багато інших популярних синтаксисів, що дозволяють писати більш компактний код.

Зокрема варто відмітити синтаксис мови Python і ML-подібний синтаксис, прикалади яких наведено на рисунках \ref{python-syntax} і \ref{ml-syntax}, відповідно.

\begin{figure}[h]
  \centering
  \begin{minted}{python}
def mymin(a, b):
    if a < b:
        return a
    else:
        return b
  \end{minted}
  \caption{Приклад синтаксису мови Python}
  \label{python-syntax}
\end{figure}

\begin{figure}[h]
  \centering
  \begin{minted}{haskell}
mymin :: Int -> Int -> Int
mymin a b = if a < b then a else b
  \end{minted}
  \caption{Приклад ML-подібного синтаксису (Haskell)}
  \label{ml-syntax}
\end{figure}

Чутливий до відступів синтаксис мови Python не використовує фігурні дужки для відокремлення вкладених блоків, що дозволяє зекономити вертикальний простір і вмістити більше діючого коду на екран. ML-подібний синтаксис іде ще далі і має дуже мінімальний синтаксис, що використовує принцип зіставлення (juxtaposition) і не вимагає додаткових ключових слів і дужок для визначення або виклику функцій, що робить код ще більш компактним.

Однак, не варто забувати, що цільову аудиторію розроблюваної мови складають програмісти, що уже працюють із такими мовами як \LangC{} і C++. Для того, щоб полегшити перехід даних програмістів і сприяти ширшому сприйняттю, розроблювана мова повинна мати C-подібний синтаксис.

\subsection{Сумісність з мовою \LangC{}}
Мова забов'язана бути сумісною з \LangC{}, оскільки на цій мові написано дуже багато існуючих бібліотек, включаючи бібліотеки підтримки від постачальників апаратного забезпечення.

Підтримка зовнішнього інтерфейсу функцій мови \LangC{} не є важкою задачею і вже було реалізовано в багатьох мовах.
Більш тісна інтеграція включає в себе синтаксичний аналіз заголовочних файлів мови \LangC{} для витягнення і забезпечення типів функцій, розгорнення макросів і т.д.

Мова Nim гарно справляється з цією частиною (що не є дивним, оскільки вона компілюється в \LangC{}).

Розроблювана мова має підтримувати зовнішний інтерфейс функцій мови \LangC{}.

\subsection{Відсутність неявних приведень}
Неявні приведення відбуваються, коли аргументи операції не відповідають необхідним, але компілятор ``знає'', як привести один тип до іншого. При цьому, в мові \LangC{}, саме значення може змінитися: обрізатися до меншої кількості біт, або змінити знак. Оскільки компілятор може вставляти такі приведення неявно без відома програміста, це часто призводить до неочевидних і складних для відлагодження програмних помилок.

Розроблювана мова не має містити жодних неявних перетворень типів, для уникнення цих проблем --- навіть розширючих перетворень між числовими типами з однаковою знаковістю.

Ця ідея не є новою, і вже успішно реалізована у таких мовах як Haskell або Rust.

Підтвердженням доречності цієї ідеї є також те, що стандарт MISRA C забороняє використання більшості неявних перетворень.

\subsection{Константні змінні}
Відомо, що константні змінні полегшують читання програмного коду, оскільки значення, що були встановлені один раз, уже не будуть змінені, тому програмістам нема необхідності ментально відслідковувати, як використовується ця змінна. Окрім того, константі змінні допомагають програмістам гарантувати, що певні значення або ділянки пам'яті ніколи не будуть змінені --- це буває досить доречним в програмуванні для вбудованих систем.

Хоча існує досить багато мов, що навіть не підтримують константні змінні (наприклад, Java, Python), це досить важлива можливість для мови у сфері програмування для вбудованих систем і систем, що потребують високої надійності.

Цікаво відмітити, що існують мови, що взагалі не підтримують неконстантні змінні (Haskell, Idris). Однак, така реалізація мови вимагає занадто високих накладних витрат, щоб бути практичною у сфері системного програмування.

Розроблювана мова має включати можливість створювати константні змінні і, більш того, всі змінні мають бути константними за замовчуванням. Компілятор має видавати діагностичні повідомлення, якщо неконстантна змінна ніколи не змінюється.

\subsection{Система ефектів}
Спрощена система ефектів дозволить відмічати окремі функції ефектами, які вони мають. Наприклад:
\begin{itemize}[nosep]
\item Функція алокує пам'ять.
\item Блокуюча функція.
\item Функція, що виконує ввід/вивід.
\item Функція, що взаємодіє з мережею.
\end{itemize}

Компілятор може автоматично вивести ефекти інших функцій, що дозволяє миттєво дізнатися відповіді на такі питання як ``чи алокує дана функція пам'ять?''. Іншою частиною системи ефектів це можливість явно дозволяти або забороняти окремі ефекти для певних функцій. Наприклад, це дозволить заборонити викликати блокуючі функції із обробників переривань (одна із найбільш розповсюджених помилок в ядрі Linux), і забезпечити виконання цієї умови під час компіляції.

\subsection{Розділення безпечного і небезпечного коду}
Мова Rust дозволяє розділяти так званий ``безпечний'' і ``небезпечний'' код.
В межах безпечного коду дозволено виконувати лише певну підмножину всіх доступних операцій, в той час як в небезпечних блоках можна виконувати будь-які дії, що підтримуються мовою.
Наприклад, в безпечних секціях не дозволенo розіменовувати вказівники, або викликати інші небезпечні функції.

Використання лише безпечної підмножини мови гарантує безпеку пам'яті. Якщо програма зазнає помилок пов'язаних із пам'яттю (наприклад, розіменування неіснуючого вказівника), помилка гарантовано знаходить в ділянці коду, що помічена як ``небезпечна''.

Ця можливість мови є корисною для зебезпечення більшої надійності програм. І хоча загальна ідея є схожою із системою ефектів, розділення коду на безпечний і небезпечний потребує додаткової підтримки від компілятора.

\subsection{Асемблерні вставки}
Низькорівневе програмування потребує доступу до спеціальних інструкцій процесора, що не можуть бути реалізовані безпосередньо в мові через їх різноманіття і специфічність.

Прикладом такого використання є реалізація переключення контексту в ядрах операційних систем. В рамках даного процесу необхідно зберігти значення всіх регістрів на стеці і потім відновити значення регістрів іншого процесу.
Іншим прикладом є зчитування значень статусних регістрів (які залежать від архітектури процесора).

Зазвичай, ці функції реалізуються за допомогою асемблерних вставок. Стандарт мови \LangC{} не включає даних механізміх, але більшість компіляторів мови \LangC{} реалізовують це власноруч.

Розроблювана мова має включати стандартні механізми для використання асемблерних вставок.

\subsection{Розширена підтримка лінковки}
Програмістам вбудованих систем доводиться вручну керувати розміщенням даних і коду програми за певними адресами.

Наприклад:
\begin{itemize}[nosep]
\item Розміщення вектору переривань на фіксованій позиції.
\item Регістри відображені в пам'яті.
\item Підтримка різних карт пам'яті.
\end{itemize}

Наразі, це реалізується за допомогою розміщенням змінних по різним секціям і використання скриптів лінковки для розміщення секцій в необхідних фрагментах адресного простору.

Розроблювана мова має підтримувати принаймні розміщення зміних у заданих секціях. Підтримка задання опису секцій і їх розміщення в адресному просторі є додатковим плюсом.

\subsection{Узагальнене програмування}
Узагальнене програмування зарекомендувало себе як важливий інструмент програмування в останні десятиріччя. Це одна із найбільш затребуваних функція, якої не хватає в мові \LangC{}, оскільки вона дозволяє створювати типо-безпечні колекції об'єктів і алгоритми.

Узагальнене програмування реалізоване у мові C++ за допомогою шаблонів, а також у мові Java (і багатьох інших) за допомогою дженериків.

Розроблювана мова має підтримувати засоби узагальненого програмування.

\subsection{Типажі}
Типажі є альтернативою стандартним механізмам ООП для забезпечення поліморфізму. На відміну від ООП, типажі дозволяють лише наслідування інтерфейсу, але не наслідування імплементації.

Відомо, що наслідування імплементації значно поскладнює розуміння програм, а також руйнує інкапсуляцію\cite{oop-must-die}.
Типажі, навпроти, значно простіше для загального розуміння, мають менше виключень і кутових випадків, при цьому є достатньо потужними для реалізації складних програм.

\subsection{Умовна компіляція}
Код операційних систем зазвичай містить дуже багато апаратно-залежних деталей, які можуть бути використані (або навіть просто скомпільовані) лише для кількох окремих апаратних платформ.
Незважаючи на це, загальна структура операційних систем є універсальної і працює однаково незалежно від цільової платформи.
Це можливо тільки за рахунок так званої ``умовної компіляції''.

Умовна компіляція дозволяє вмикати або вимикати певні фрагменти програмного коду в залежності від певних умов, що можуть перевірятися під час компіляції.

У мові \LangC{}, дана можливість представлена препроцесором, а саме директивами \code{\#if} та \code{\#ifdef}, \code{\#ifndef}, \code{\#else}, \code{\#elif} та \code{\#endif}. Приклад використання умовної компіляції наведено на рисунку \ref{conditional-compilation}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{c}
#ifdef __unix__ /* __unix__ is usually defined by compilers targeting Unix systems */
# include <unistd.h>
#elif defined _WIN32 /* _WIN32 is usually defined by compilers targeting 32 or 64 bit Windows systems */
# include <windows.h>
#endif
  \end{minted}
  \caption{Приклад використання умовної компіляції}
  \label{conditional-compilation}
\end{figure}

Розроблювана мова повинна мати механізми для підтримки умовної компіляції.

\subsection{Вирази часу компіляції}
Вирази часу компіляції це можливість компілятора виконувати розрахунки під час компіляції програм, що дозволяє виконувати ще більше оптимізацій.

Можливість здійснювати нетривіальні розрахунки на етапі компіляції дозволяє пришвидшити програми (оскільки не треба буде робити ці розрахунки під час виконання) і зекономити пам'ять (оскільки результат зазвичай займає менше місця).

Також, вирази часу компіляції роблять умовну компіляцію більш потужною, оскільки дозволяють перевіряти більш складні умови.

\subsection{Розрахунок максимального розміру стеку на етапі компіляції}
Програми для вбудованих систем майже завжди працюють зі стеком фіксованого розміру. Одна із розповсюджених помилок --- це розміщення великих об'єктів на стеці, що призводить до його виснаження.

За відсутності рекурсії, компілятор має змогу розрахувати максимальний об'єм стеку, що може бути використаний будь-якою функцією. Це, в свою чергу, допоможе гарантувати, що програма ніколи не вийде за виділений для неї об'єм стеку.

\subsection{Опціональні перевірки часу виконання}
Компілятор розроблюваної мови може вставляти додаткові перевірки часу виконання для відлавлювання ще більшої кількості програмних помилок.

Прикладами таких перевірок можуть бути:
\begin{itemize}[nosep]
\item Перевірка виходу за границі масиву перед зверненням до комірки пам'яті.
\item Перевірка виходу за границі програмного стеку.
\item Перевірка переповнення цілочисельних значень перед виконанням арифметичних операцій.
\item Перевірка ділення на нуль.
\item Перевірка значення вказівника на \code{NULL}.
\end{itemize}

Переповнення буферу є однією із найрозповсюдженіших програмних помилок, що призводять до вразливостей безпеки, і є причиною багатьох відомих дір в безпеці, в тому числі Heartbleed\cite{heartbleed} і Blueborne\cite{blueborne}.
Включення даних перевірок за замовчуванням допоможе запобігти широкого класу таких помилок і підвищити безпеку програм.

Однак, недоліком даних перевірок є те, що вони використовують додаткові цикли процесора і тим самим зменшують продуктивність скомпільованих програм, оскільки, в загальному випадку, ці перевірки не можуть бути виконані на етапі компіляції і мають бути застосовані лише під час виконнання (хоча компілятор і може усунути деякі перевірки за допомогою статичного аналізу коду).

Додаткові перевірки часу виконання мають бути включеними за замовчуваннями, але компілятор має надавати можливість вимкнути окремі класи перевірок для програм, які потребують максимальної продуктивності.

\subsection{Гарантована оптимізація хвостових викликів}
Хвостовий виклик, це виклик процедури, що виконується як фінальна дія процедури.

Оптимізація хвостових викликів (Tail Call Optimization, TCO) це техніка, що дозволяє імплементацію хвостових викликів без додавання нових стекових кадрів (stack frame) до стеку викликів. Наприкінці виконання процедури, більшість її активного стекового кадру вже не потрібна, одже може бути заміщена стековим кадром хвостового виклику. Після цього, програма може стрибнути на процедуру, що викликається. Ця техніка також називається ``усунення хвостових викликів''.

За допомогою даної оптимізації стає можливим реалізація певних рекурсивних алгоритмів без росту розміру стеку викликів.
Це може бути важливим для програмування вбудованих систем, оскільки майже завжди розмір стеку є обмеженим.

\section{Опис мови}
\newcommand{\deftype}[1]{\textbf{\code{#1}}}
\newcommand{\typeitem}[1]{\item \deftype{#1}.}

\FloatBarrier
\subsection{Коментарі}
Багато-рядкові коментарі можуть призвести до неочікуваних помилок.
Вкладені коментарі також можуть викликати питання (чи вони підтримуються).

Однорядкові коментарі, навпроти, максимально прості і однозначні.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
// Мова підтримує лише однорядкові коментарі

// Для того, щоб продовжити коментар на наступному
// рядку, рядок має розпочинатися з нового коментарю.
  \end{minted}
  \caption{Приклад коментарів у розроблюваній мові}
  \label{lang:comments}
\end{figure}

EBNF для коментарів приведено на рисунку \ref{ebnf:comment}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
comment = '/', '/', {all characters - '\n'};

all characters = ? all unicode characters ?;
  \end{minted}
  \caption{EBNF для коментарів}
  \label{ebnf:comment}
\end{figure}

\FloatBarrier
\subsection{Ідентифікатори}
Ідентифікаторами (або іменами) може бути будь-яка послідовність, що складається з латинських букв, цифр і знаку підкреслення, і починається із букви або знаку підкреслення.

EBNF для ідентифікаторів приведено на рисунку \ref{ebnf:id}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
id = (alpha | "_"), {alpha | "_" | digit};

alpha = ? all latin letters ?;
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
  \end{minted}
  \caption{EBNF для ідентифікаторів}
  \label{ebnf:id}
\end{figure}

\FloatBarrier
\subsection{Тип void}
Розроблювана мова включає у себе тип \deftype{void}, що має єдине можливе значення --- \code{void}.
Дане значення займає нуль байт і повністю оптимізується компілятором (не присутнє під час виконання).

Це відрізняється від підходу в мові \LangC{}, де тип \code{void} не має жодних значень.
Ця особливість стане в нагоді для визначення більш потужних властивостей системи типів.

Тип \code{void} підтримує лише операції перевірки на рівність (\code{==} і \code{!=}). (Всі \code{void} значення рівні між собою).

\FloatBarrier
\subsection{Логічний тип}
Розроблювана мова підтримує логічний тип \deftype{bool}.
Він має два можливих значення: \code{true} і \code{false}.
Використовується в логічних операціях, а також в умовах операторів.

Список операцій, що підтримуються між двома значеннями логічного типу наведено у таблиці \ref{lang:bool:operators}.

\begin{table}
  \tabulinesep=1mm
  \begin{tabu}{|l|X[l]|l|}
    \hline
    Символ операції & Операція & Тип результату \\
    \hline
    \code{<}    & Менше & \code{bool} \\
    \code{>}    & Більше & \code{bool} \\
    \code{<=}   & Менше-дорівнює & \code{bool} \\
    \code{>=}   & Більше-дорівнює & \code{bool} \\
    \code{==}   & Дорівнює & \code{bool} \\
    \code{!=}   & Не дорівнює & \code{bool} \\
    \code{\&\&} & Логічне І & \code{bool} \\
    \code{||}   & Логічне АБО & \code{bool} \\
    \hline
  \end{tabu}
  \caption{Операції, що підтримуються над логічним типом}
  \label{lang:bool:operators}
\end{table}

При порівнюванні значень, \code{false} є меншим за \code{true}.

\FloatBarrier
\subsection{Числа}
Розроблювана мова підтримує наступні числові типи:
\begin{itemize}[nosep]
\typeitem{u8} 8-бітне беззнакове ціле.
\typeitem{i8} 8-бітне знакове ціле.
\typeitem{u16} 16-бітне беззнакове ціле.
\typeitem{i16} 16-бітне знакове ціле.
\typeitem{u32} 32-бітне беззнакове ціле.
\typeitem{i32} 32-бітне знакове ціле.
\typeitem{u64} 64-бітне беззнакове ціле.
\typeitem{i64} 64-бітне знакове ціле.
\end{itemize}

Числа з плаваючою точкою не підтримуються в рамках даної дипломного проекту, оскільки вони досить рідко використовуються в системному програмному забезпеченні, а в деяких випадках (програмування ядер операційних систем), використання чисел із плаваючою точкою заборонене.
Підтримка чисел із плавоючою точкою може бути реалізована в наступній версії мови.

Числа можуть бути введені у звичайній десятковій системі числення, а також у шістнадцятковій або двійковій.
Система числення задається за допомогою префікса.
Префікси \code{0x} і \code{0b} використовуються для задання шістнадцяткових і двійкових чисел відповідно; десяткові числа не потребують префіксів.
Окрім того, можна вказати точний тип числа за допомогою використання постфіксів.
Це дає змогу уникнути неоднозначностей.

Приклади числових літералів, що підтримуються, наведено на рисунку \ref{lang:literals:numbers}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
// десяткові числа
0
15
42
-13

// шістнадцяткові числа
0x1234

// двійкові числа
0b01011001

// специфікація типів
15u8    // 8-bit unsigned integer
0xFFu8  // 8-bit unsigned integer
0i32    // 32-bit signed integer
  \end{minted}
  \caption{Приклади числових літералів у розроблюваній мові}
  \label{lang:literals:numbers}
\end{figure}

EBNF для числових літералів наведено на рисунку \ref{ebnf:numbers}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
number = number value, [number type specifier];

number value = hexadecimal number
  | binary number
  | decimal number;

hexadecimal number = '0x', hex digit, {hex digit};
binary number = '0b', binary digit, {binary digit};
decimal number = digit, {digit};

hex digit = digit |
  'A' | 'B' | 'C' | 'D' | 'E' | 'F' |
  'a' | 'b' | 'c' | 'd' | 'e' | 'f';

binary digit = '0' | '1';

number type specifier =
  'u8' | 'u16' | 'u32' | 'u64' |
  'i8' | 'i16' | 'i32' | 'i64';
  \end{minted}
  \caption{EBNF для числових літералів}
  \label{ebnf:numbers}
\end{figure}

Список операцій, що підтримуються між числами однакового типу наведено у таблиці \ref{lang:numbers:binary-operations}, де \emph{number} означає тип аргументів.

\begin{table}
  \tabulinesep=1mm
  \begin{tabu}{|l|X[l]|l|}
    \hline
    Символ операції & Операція & Тип результату \\
    \hline
    \code{+} & Додавання & \emph{number} \\
    \code{-} & Віднімання & \emph{number} \\
    \code{*} & Множення & \emph{number} \\
    \code{/} & Цілочисельне ділення & \emph{number} \\
    \code{\%} & Залишок від цілочисельного ділення & \emph{number} \\
    \code{\&} & Побітове І & \emph{number} \\
    \code{|} & Побітове АБО & \emph{number} \\
    \code{\^{}} & Побітове виключне АБО & \emph{number} \\
    \code{>} & Більше & \code{bool} \\
    \code{<} & Менше & \code{bool} \\
    \code{>=} & Більше-дорівнює & \code{bool} \\
    \code{<=} & Менше-дорівнює & \code{bool} \\
    \code{==} & Дорівнює & \code{bool} \\
    \code{!=} & Не дорівнює & \code{bool} \\
    \hline
  \end{tabu}
  \caption{Список операцій над числами одного типу}
  \label{lang:numbers:binary-operations}
\end{table}

Побітові здвиги підтримуються для будь-яких чисел за умови, що другий операнд є числом будь-якого беззнакового типу. Результат операції має тип першого операнду.
Символ \code{\textless\textless} означає побітовий здвиг вліво, а \code{\textgreater\textgreater} --- побітовий здвиг вправо.

Також, підтримується операція побітового НІ, які позначається символом ``\code{!}''. Наприклад, результатом операції \code{!0x0Fu8} є \code{0xF0u8}.

За замовчуванням, для операцій додавання, віднімання і множення компілятор має вставляти перевірки часу виконання на переповнення; для операції ділення додатково перевіряється, що дільник не дорівнює нулю.

\FloatBarrier
\subsection{Вказівники}
Вказівники в розроблюваній мові підтримують функціонал аналогічний до функціоналу вказівників у мові \LangC{}.
Вони можуть вказувати на певну ділянку пам'яті, можуть бути розіменовані, а також підтримують адресну арифметику.
Кілька вказівників можуть вказувати на одну ділянку пам'яті.

Мова підтримує спецільний літерал \code{null}, що означає нульовий вказівник будь-якого типу (аналог \code{NULL} із мови \LangC{}).

Вказівники можуть бути утворені за допомогою операції взяття адреси, або за допомогою приведення значень числового типу відповідного розміру до типу вказівника.

Розроблювана мова підтримує два типи вказівників, що відрязняються константністю значення, на яке вони вказують.
\begin{itemize}
\typeitem{*\emph{type}}
Вказівник на незмінюване значення типу \emph{type}.
Наприклад, вказівник на значення логічного типу має тип \code{*bool}.
\typeitem{*mut \emph{type}}
Вказівник на змінюване значення типу \emph{type}.
Наприклад, вказівник на значення логічного типу має тип \code{*mut bool}.
\end{itemize}

Будь-які операції над вказівниками вважаються ``небезпечними'' і мусять відбуватися у відповідних блоках.

\FloatBarrier
\subsection{Посилання}
Посилання є ``безпечним'' аналогом вказівників і їх використання всіляко заохочується.

Посилання підтримують обмежену кількість операцій: вони не підтримують адресну арифметику, не можуть вказувати на \code{null}. Кілька посилань не можуть вказувати на одну і ту саму ділянку пам'яті.

Посилання можуть бути утворені за допомогою операції взяття адреси, або за допомогою приведення значення вказівника до посилання (що є ``небезпечною'' операцією, оскільки це може утворити посилання, що вказує на \code{null}).

Як і з вказівниками, розроблювана мова підтримує два типи посилань, що відрязняються константністю значення, на яке вони вказують.
\begin{itemize}
\typeitem{\&\emph{type}}
Посилання на незмінюване значення типу \emph{type}.
Наприклад, посилання на значення логічного типу має тип \code{\&bool}.
\typeitem{\&mut \emph{type}}
Посилання на змінюване значення типу \emph{type}.
Наприклад, посилання на значення логічного типу має тип \code{\&mut bool}.
\end{itemize}

Всі операції над посиланнями є ``безпечними'' і не потребують спеціальних блоків.

\FloatBarrier
\subsection{Масиви}
Тип масиву значень типу \emph{type}, що містить \emph{N} елементів записується як \deftype{[\emph{type};~\emph{N}]}.

На відміну від мови \LangC{}, масиви не приводяться до типу вказівника на елемент. Для цього можна використати конструкцію \code{\&arr[0]}, або метод \code{as\_ptr()}.

Для задання масиву у програмі, достатньо перерахувати всі елементи масива через кому і оточити їх у квадратні дужки.

Масиви підтримують операцію індексування. Приклад її використання наведено на рисунку \ref{lang:array:access}. Якщо елементів підтримує операції порівнювання, вони також можуть бути застосовані для масиву в цілому.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
let x = [1, 2, 3];
assert!(x[0] == 1);
assert!(x[1] == 2);
assert!(x[2] == 3);

let arr: [[u8; 32]; 32];
arr[13][14] = 10;
  \end{minted}
  \caption{Приклад двовимірного масиву і індексування}
  \label{lang:array:access}
\end{figure}

Окрім того, масиви підтримують наступні методи:
\begin{itemize}
\item \code{len()}. Повертає довжину масиву.
\item \code{is\_empty()}. Повертає \code{true}, якщо довжина масиву дорівнює нулю.
\item \code{as\_ptr()}. Повертає вказівник на перший елемент масиву.
\item \code{contains()}. Повертає \code{true}, якщо масив містить елемент із заданим значенням.
\item \code{starts\_with()}. Повертає \code{true}, якщо вказаний аргумент є префіксом масиву.
\item \code{ends\_with()}. Повертає \code{true}, якщо вказаний аргумент є суфіксом масиву.
\item \code{swap()}. Обмінює місцями два вказаних елементи масиву.
\item \code{reverse()}. Розгортає порядок елементів у масиві.
\item \code{sort()}. Сортує елементи масиву за порядком.
\item \code{iter()}. Повертає ітератор на елементи масиву.
\end{itemize}

\FloatBarrier
\subsection{Зрізи масивів}
Зріз масиву\cite{array-slicing} елементів типу \emph{type} записується як \deftype{[\emph{type}]}.

Зріз складається із вказівника на перший елемент масиву і числа, що зберігає кількість елементів.

Зріз можна отримати за допомогою спеціальної операції, приклад використання якої наведено на рисунку \ref{lang:slicing}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
let arr: [u8; 32];

arr[0..3] // зріз масиву з 0 по 3 елементи включно
  \end{minted}
  \caption{Приклад отримання зрізу масиву}
  \label{lang:slicing}
\end{figure}

Зрізи підтримують наступні методи:
\begin{itemize}
\item \code{len()}. Повертає довжину зрізу.
\item \code{is\_empty()}. Повертає \code{true}, якщо довжина зрізу дорівнює нулю.
\item \code{as\_ptr()}. Повертає вказівник на перший елемент зрізу.
\item \code{contains()}. Повертає \code{true}, якщо зріз містить елемент із заданим значенням.
\item \code{starts\_with()}. Повертає \code{true}, якщо вказаний аргумент є префіксом зрізу.
\item \code{ends\_with()}. Повертає \code{true}, якщо вказаний аргумент є суфіксом зрізу.
\item \code{swap()}. Обмінює місцями два вказаних елементи зрізу.
\item \code{reverse()}. Розгортає порядок елементів у зрізі.
\item \code{sort()}. Сортує елементи зрізу за порядком.
\item \code{iter()}. Повертає ітератор на елементи зрізу.
\end{itemize}

\FloatBarrier
\subsection{Рядки}
Рядки у розроблюваній мові представлені як масив беззнакових байтів.

Підтримуються рядкові літерали, які можуть бути будь-яким набором символів оточених в подвійні лапки.
Багаторядкові рядкові літерали не дозволені.

Підтримується екранування символів за допомогою оберненої косої риски (\code{\textbackslash}).
Таблиця екранованих послідовностей, що підтримуються, наведена у таблиці \ref{lang:escape-sequences}.

Також, мова дозволяє різні інтерпретації рядкових літералів під час компіляції за допомогою префіксів.
Прикладом такої інтерпретації є префікс \code{b}, що інтерпретує строковий літерал як масив беззнакових байтів (тип \code{u8}, на відміну від типу \code{char}, що підтримує кодування Unicode символів).
Така інтерпретація корисна, так як дозволяє не використовувати Unicode в програмах, що не потребують цього (що є особливо корисним в системах з обмеженою пам'яттю).

Приклади рядкових літералів наведено на рисунку \ref{lang:literals:strings}.

\begin{table}
  \tabulinesep=1mm
  \begin{tabu}{|l|l|X[l]|}
    \hline
    Екранована послідовність & Шістнадцяткове значення & Символ \\
    \hline
    \code{\textbackslash{}n} & 0x0A & Новий рядок \\
    \hline
    \code{\textbackslash{}r} & 0x0D & Повернення каретки \\
    \hline
    \code{\textbackslash{}t} & 0x09 & Горизонтальний таб \\
    \hline
    \code{\textbackslash{}\textbackslash{}} & 0x5C & Обернена коса риска \\
    \hline
    \code{\textbackslash{}'} & 0x27 & Одинарна лапка \\
    \hline
    \code{\textbackslash{}"} & 0x22 & Подвійна лапка \\
    \hline
    \code{\textbackslash{}x\emph{hh}} & будь-який & Байт, значення якого є \code{\emph{hh}} інтерпретоване як шістнадцяткове число \\
    \hline
  \end{tabu}
  \caption{Список екранованих послідовностей}
  \label{lang:escape-sequences}
\end{table}

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
"this is a string literal"

"line1\nline2\nline3"

"He said: \"hello\""

b"this is a bytestring"
  \end{minted}
  \caption{Приклади рядкових літералів у розроблюваній мові}
  \label{lang:literals:strings}
\end{figure}

EBNF для рядкових літералів наведено на рисунку \ref{ebnf:string-literals}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
string = '"', {all characters - '\n' - '\\' | '\\', escaped symbol}, '"';

escaped symbol = 'n' | 'r' | 't' | '\\' | "'" | '"'
  | 'x', hexadecimal digit, hexadecimal digit;
  \end{minted}
  \caption{EBNF для рядкових літералів}
  \label{ebnf:string-literals}
\end{figure}

\FloatBarrier
\subsection{Кортежі}
Розроблювана мова підтримує типи кортежів.

Тип кортежу записується наступним чином: \deftype{(\emph{type1}, \emph{type2}\emph{[, \ldots]})}.
І означає кортеж із типів \emph{type1\ldots{}typeN}.

З точки зору алгебраїчних типів даних (ADT, Algebraic Data Type), кортежі можуть розглядатися як добуток типів.
(Значення кортежу містить в собі по одному значенню кожного із зазначених типів).

Наприклад, кортеж із 8-бітного беззнакового цілого, логічного значення і вказівника має тип \code{(u8, bool, *u8)}. Прикладом значення такого типу може бути \code{(42, true, null)}.

Доступитися до значень у кортежі можна за допомогою операцій доступу до поля.
Назви полей є натуральні числа починаючи з нуля.
Приклад такого використання наведено на рисунку \ref{lang:tuple:access}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
(42, true, null).0 == 42

(42, true, null).1 == true

(42, true, null).2 == null
  \end{minted}
  \caption{Приклад доступу до полів кортежу}
  \label{lang:tuple:access}
\end{figure}

\FloatBarrier
\subsection{Структури}
Структури дозволяють групувати дані різних типів, даючи їм імена, тим самим вони є більш організованим способом, ніж кортежі.

Загальні форми оголошення структури і створення її екземплярів наведено на рисунку \ref{lang:struct:usage}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
// Оголошення структури struct_name
struct struct_name {
    field1: type1;
    field2: type2;
    ...
    fieldN: typeN;
}

// Просте створення екземпляру
let x = struct_name{ value1, value2, ..., valueN };

// Створення екземпляру з використанням
// іменованих полей
let y = struct_name{
  field1: value1,
  field2: value2,
  ...
  fieldN: valueN,
};
  \end{minted}
  \caption{Оголошення типу структури і створення її екземплярів}
  \label{lang:struct:usage}
\end{figure}

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
struct definition = ['pub'], 'struct', id,
  '{', {field definition}, '}';

field definition = ['pub'], id, ':', type, ';';
  \end{minted}
  \caption{EBNF для оголошення структур}
  \label{ebnf:struct}
\end{figure}

Доступ до полей структури може бути виконаний за допомогою оператора ``\code{.}''.
Приклад його використання наведено на рисунку \ref{lang:struct:access}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
struct my_struct {
    my_number: u32;
    my_bool: bool;
    my_pointer: *u8;
};

let x = my_struct{ 42, true, null };

x.my_number == 42
x.my_bool == true
x.my_pointer == null
  \end{minted}
  \caption{Приклад доступу до полей структури}
  \label{lang:struct:access}
\end{figure}

\FloatBarrier
\subsection{Типи перерахування}
Розроблювана мова підтримує типи перерахування.

Визначення перерахування створює окремий тип, що не приводиться автоматично до інших типів. (На відміну від мови \LangC{}, де \code{enum} всього лише визначає константи в глобальному просторі імен). Ця особливість схожа до \code{enum class} в мові C++\cite{c++:enums}.

Доступ до значень перерахування може бути отриманий за допомогою оператора простору імен.

Приклад використання перерахувань зображено на рисунку \ref{lang:enum}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
enum Weekday {
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday,
  Sunday,
}

let today = Weekday::Monday;
  \end{minted}
  \caption{Приклад використання перерахувань}
  \label{lang:enum}
\end{figure}

EBNF для оголошення перерахувань наведено на рисунку \ref{ebnf:enum}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
enum definition = ['pub'], 'enum', id,
  '{', enum options, '}';

enum options = [option, [',', enum options], [',']];

option = id, ['=', expression];
  \end{minted}
  \caption{EBNF для оголошення перерахувань}
  \label{ebnf:enum}
\end{figure}

\FloatBarrier
\subsection{Функції}
Розроблювана мова підтримує функції визначені користувачем. Загальна форма визначення функції наведена на рисунку \ref{lang:function:definition}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
fn function_name(arg1: type1): rettype {
  function;
  body;

  return_value
}
  \end{minted}
  \caption{Загальна форма визначення функції}
  \label{lang:function:definition}
\end{figure}

EBNF для визначення функцій наведено на рисунку \ref{ebnf:function}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
function def = ['pub'], id, '(', args, ')', ':', type,
  compound statement;

args = [argument, [',', args]];

argument = id, ':', type;
  \end{minted}
  \caption{EBNF для визначення функцій}
  \label{ebnf:function}
\end{figure}

Всі функції мають тип \deftype{fn(\emph{type1}\emph{[, \ldots]}): \emph{rettype}}, де \emph{type1 \ldots{} typeN} є типами аргументів функції, а \emph{rettype} є типом значення, що повертається.
Назва функції є значенням даного типу.

Даний тип підтримує лише операції присваювання і виклику, а також може бути переданий як аргумент функції.

\FloatBarrier
\subsection{Блоки імплементації}
Структури і інші типи можуть бути розширені методами за допомогою блоків імплементації.
Типи можуть мати більше одного блоку імплементації, що значить, що типи можуть бути розширені, навіть якщо вони знаходяться у сторонніх бібліотеках.

На рисунку \ref{lang:impl-block} наведено кілька прикладів розширення типів.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
struct Rectange {
    length: u32;
    width: u32;
}

impl Rectange {
    pub fn square(length: u32): Rectangle {
        Rectange{
          length: length,
          width: length,
        }
    }
    pub fn area(self: &Self): u32 {
        self.length * self.width
    }
    pub fn perimeter(self: &Self): u32 {
        (self.length + self.width) * 2
    }
}

impl u32 {
    pub fn pow2(self: Self): u32 {
        self * self
    }
}
  \end{minted}
  \caption{Приклад розширення типів за допомогою блоків імплементації}
  \label{lang:impl-block}
\end{figure}

EBNF для блоків імплементації наведено на рисунку \ref{ebnf:impl}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
impl block = 'impl', [type, 'for'], type,
  '{', {function def}, '}';
  \end{minted}
  \caption{EBNF для блоків імплементацій}
  \label{ebnf:impl}
\end{figure}

Варто також помітити, що розширення дозволене навіть для стандартних типів, що значно збільшує гнучкість.

Блоки імплементації дозволяють додавати як методи екземпляру, так і методи типу.
Якщо ім'я першого параметру метода є \code{self}, то даний метод є методом екземпляру; в інакшому випадку --- він є методом типу.

В середині блоку імплементації спеціальне ім'я \code{Self} означає тип, для якого цей блок застосовується. Наприклад, в першому блоці на рисунку \ref{lang:impl-block}, \code{Self} відповідає типу \code{Rectange}, а в другому блоці --- \code{u32}.

Параметр \code{self} може мати один із наступних типів:
\begin{itemize}[nosep]
\item \code{Self}
\item \code{\&Self}
\item \code{\&mut Self}
\item \code{*Self}
\item \code{*mut Self}
\end{itemize}
Інші типи для параметру \code{self} не дозволені.

Методи екземпляра можуть бути викликані за допомогою оператору доступу застосованого до екземпляра типу. Методи типу можуть бути викликані за допомогою оператору простору імен (\code{::}). Приклад використання методів визначених на рисунку \ref{lang:impl-block} наведено на рисунку \ref{lang:impl-usage}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
let r = Rectangle::square(2);
assert!(r.area() == 4);
assert!(r.perimeter() == 8);

assert!(4u32.pow2() == 16);
  \end{minted}
  \caption{Приклад використання методів}
  \label{lang:impl-usage}
\end{figure}

\FloatBarrier
\subsection{Типажі}
Типажі це особливість мови, що символізує компілятору, яку функціональність має забезпечити певний тип.
Типажі дуже схожі на інтерфейси в мові Java, однак характерною особливістю є те, що реалізація інтерфейсів не має знаходитися всередині визначення класу, а може бути надана окремо.

Приклад визначення типажу наведено на рисунку \ref{lang:trait-declaration}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
trait Figure {
    fn area(self: &Self): u32;

    fn perimeter(self: &Self): u32;
}
  \end{minted}
  \caption{Приклад визначення типажу}
  \label{lang:trait-declaration}
\end{figure}

Реалізація типажу може бути надана за допомогою блоку імплементації. Приклад реалізації типажу, визначеного на рисунку \ref{lang:trait-declaration}, наведено на рисунку \ref{lang:trait-implementation}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
impl Figure for Rectange {
    pub fn area(self: &Self): u32 {
        self.length * self.width
    }
    pub fn perimeter(self: &Self): u32 {
        (self.length + self.width) * 2
    }
}

struct RightTriangle {
    length: u32;
    width: u32;
}

impl Figure for RightTriangle {
    pub fn area(self: &Self): u32 {
        (self.length * self.width) / 2
    }
    pub fn perimeter(self: &Self): u32 {
        self.length +
          self.width +
          (self.length*self.length +
            self.width*self.width).sqrt()
    }
}
  \end{minted}
  \caption{Приклад реалізації типажу}
  \label{lang:trait-implementation}
\end{figure}

Якщо на етапі визначення типажу уже відомо, як зазвичай будуть реалізовувати певний метод, можна вказати його реалізацію за замовчуванням.
Рисунок \ref{lang:trait-default} наводить приклад такого випадку, де метод \code{is\_invalid()} визначений як протилежність метода \code{is\_valid()}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
trait Foo {
    fn is_valid(self: &Self): bool;

    fn is_invalid(self: &Self): bool {
        !self.is_valid()
    }
}
  \end{minted}
  \caption{Приклад використання імплементації метода за замовчуванням}
  \label{lang:trait-default}
\end{figure}

Типажі можуть наслідуватися. Якщо типаж \code{B} наслідується від типажу \code{A}, то тип, що хоче реалізувати \code{B}, також забов'язаний реалізувати типаж \code{A}. Синтаксис наслідування типажів продемонстровано на рисунку \ref{lang:trait-inheritance}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
trait A {
    fn method_a(self: &Self): bool;
}

// Типаж B наслідується від типажу A
trait B : A {
    fn method_b(self: &Self): bool;
}

struct Test {
    result: bool;
}

impl A for Test {
    pub fn method_a(self: &Self): bool {
        self.result
    }
}

impl B for Test {
    pub fn method_b(self: &Self): bool {
        !self.result
    }
}
  \end{minted}
  \caption{Синтаксис для наслідування типажу}
  \label{lang:trait-inheritance}
\end{figure}

EBNF для визначення типажів наведено на рисунку \ref{ebnf:trait}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
trait def = 'trait', type, [':', type],
  '{', {function def | function decl}, '}';

function decl = ['pub'], id, '(', args, ')', ':', type;
  \end{minted}
  \caption{EBNF для визначення типажів}
  \label{ebnf:trait}
\end{figure}

\FloatBarrier
\subsection{Виведення типів}
Розроблювана мова підтримує глобальне виведення типів (``type inference'' або ``type reconstruction'').
В більшості місць, де необхідно вказати тип, можна вказати спеціальний тип-заповнювач, що позначається за символом підкреслення: ``\code{\_}''.

Якщо компілятор не зможе реконструювати тип заповнювача, компіляція програми буде перервана.

Кожне використання типу-заповнювача інстанціює нову змінну-тип. Іншими словами це значить, що всі використання типу-заповнювача незалежні і можуть бути виведені в різні типи.

Для того, щоб звернутися до певного типу-заповнювача, розроблювана мова підтримує іменовані типи-заповнювачі.
Іменованим типом-заповнювачем є будь-яке ім'я, що починається з одного підкреслення.
Однакові іменовані типи-заповнювачі будуть реконструювані до спільного типу.

За поведінкою, типи-заповнювачі дуже схожі до підстановочних типів у мові Haskell\cite{haskell:type-wildcards}.

Приклад використання типів-заповнювачів наведено на рисунку \ref{lang:type-placeholder}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
// виведений тип: bool
let x: _ = true;

// виведений тип: u8
let y: _ = 42;
y + 3u8;

// виведений тип: [u16; 0]
let z: _ = [];
fn a(arg: [u16]): void;
a(z);

// виведений тип: fn(u8, u8): u8
fn b(a: u8, b: _): _ {
  a + b
}
  \end{minted}
  \caption{Приклад використання типів-заповнювачів}
  \label{lang:type-placeholder}
\end{figure}

EBNF для типів-заповнювачів наведено на рисунку \ref{ebnf:type-placeholder}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
type placeholder = '_', {alpha | digit};
  \end{minted}
  \caption{EBNF для типів-заповнювачів}
  \label{ebnf:type-placeholder}
\end{figure}

\FloatBarrier
\subsection{Змінні}
Розроблювана мова підтримує визначення змінюваних і константних змінних.
За замовчуванням, змінна є константною.
Для створення неконстантної змінної, необхідно додати ключове слово \code{mut} (від слова ``mutable'').

Приклад визначення змінних продемонстровано на рисунку \ref{lang:variables}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
// незмінювана змінна
let x: u32 = 5;
x = 6; // помилка!

// змінювана змінна
let mut y: u32 = 42;
y = 15;
  \end{minted}
  \caption{Приклад визначення змінних}
  \label{lang:variables}
\end{figure}

\FloatBarrier
\subsection{Константи}
Окрім незмінюваних змінних, розроблювана мова підтримує константи часу компіляції.
Компілятор гарантує, що їх значення буде підраховано під час компіляції і не може змінюватися.

Приклад оголошення константи наведено на рисунку \ref{lang:const}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
const x: u32 = 5;
  \end{minted}
  \caption{Приклад оголошення константи}
  \label{lang:const}
\end{figure}

\FloatBarrier
\subsection{Умовний оператор}
Синтаксис умовного оператора наведено на рисунку \ref{lang:if-syntax}, де \code{condition} є виразом логічного типу, а \code{expr1} і \code{expr2} мають однаковий тип.
Умовний оператор є виразом, результуючий тип якого дорівнює типу \code{expr1} і \code{expr2}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
if condition { expr1 } else { expr2 }

if condition1 {
  expr1
} else if {
  expr2
} else {
  expr3
}

if condition { expr1 }
// аналогічно до
if condition { expr1 } else { void }
  \end{minted}
  \caption{Синтаксис умовного оператора}
  \label{lang:if-syntax}
\end{figure}

Як в усіх мовах програмування, вираз \code{expr1} буде розраховано, коли умова дорівнює \code{true}; в протилежному випадку буде розраховано вираз \code{expr2}.

Якщо гілка \code{else} складається з одного умовного оператора, фігурні дужки можна опустити, що показано в другому прикладі на рисунку \ref{lang:if-syntax}.
В усіх інших випадках фігурні дужки навколо гілок умовного виразу обов'язкові.

Гілку \code{else} можна опустити.
В цьому випадку, це буде аналогічно поверненню \code{void} з цієї гілки.
Це означає, що гілка \code{then} також має повертати \code{void}.

EBNF для умовних виразів наведено на рисунку \ref{ebnf:if}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{ebnf}
conditional expr =
  'if', expression, compound statement,
  ['else', (conditional expr | compound statement)];
  \end{minted}
  \caption{EBNF для умовного оператора}
  \label{ebnf:if}
\end{figure}

\FloatBarrier
\subsection{Цикли}
Розроблювана мова підтримує цикл \code{while}, що має форму зазначену на рисунку \ref{lang:while}.

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
while condition {
    statements;
}
  \end{minted}
  \caption{Загальна форма циклу \code{while}}
  \label{lang:while}
\end{figure}

Під час виконання, спочатку розраховується умова. Якщо умова виконується, тіло циклу виконується допоки умова є дійсною; в інакшому випадку, тіло циклу не виконується.

У тілі циклу можна використовувати ключові оператори \code{continue} і \code{break}:
\begin{itemize}[nosep]
\item \code{continue} завершує поточну ітерацію циклу і переходить до перевірки умови для наступної ітерації.
\item \code{break} завершує цикл повністю. Може повертати значення із циклу. Синтаксис для даної можливості наведено на рисунку \ref{lang:break-value}.
\end{itemize}

\begin{figure}[h]
  \centering
  \begin{minted}[breaklines]{rust}
let mut i = 0;
let x = while true {
  if i >= 10 {
    break i;
  }
  i = i + 1;
};

assert!(x == 10);
  \end{minted}
  \caption{Повернення значення із циклу за допомогою оператора \code{break}}
  \label{lang:break-value}
\end{figure}

\chapterconslusions{}
У даному розділі було проаналізовано середовище системного програмування і програмування для вбудованих пристроїв.
Було виявлено основні вимоги і обмеження для мови програмування у даній сфері.

Було сформовано головні пріоритети при розробці мови, а саме: зменшення кількості програмних помилок без зниження продуктивності компілюємих програм.

Було проаналізовано ряд наукових видань і виявлено типові помилки, що допускають програмісти системного програмного забезпечення, а також запропоновано шляхи їх уникнення.

Було сформовано список і надано детальний опис бажаних характеристик мови.

Відштовхуючись від зібраної інформації, було розроблено мову і надано її опис, включаючи приклади і опис EBNF для найбільш важливих частин.

% \chapter{Реалізація системи та тестування}
% \chapter{Аналіз отриманих результатів}

\clearpage
\begin{thebibliography}{00}
  \bibitem{stewart-bill:history-of-c}
    \eresource{History of C Programming Language}{http://www.livinginternet.com/i/iw\_unix\_c.htm}

  \bibitem{idris}
    \eresource{Idris | A Language with Dependent Types}{http://www.idris-lang.org/}
  \bibitem{idris:first-release}
    \eresource{idris: Dependently Typed Functional Programming Language}{http://hackage.haskell.org/package/idris-0.1.3}
  \bibitem{haskell:atom}
    \eresource{atom: An EDSL for embedded hard realtime applications}{https://hackage.haskell.org/package/atom}
  \bibitem{haskell:ivory}
    \eresource{Ivory - index}{http://ivorylang.org/index.html}
  \bibitem{haskell}
    \eresource{Haskell Language}{https://www.haskell.org/}

  \bibitem{nim}
    \eresource{Nim Programming Language}{http://nim-lang.org/}
  \bibitem{nim:directives}
    \eresource{Nim Manual}{http://nim-lang.org/docs/manual.html\#pragmas}
  \bibitem{nim:volatile}
    \eresource{\{.volatile.\} is almost useless · Issue \# 3382 · nim-lang/Nim}{https://github.com/nim-lang/Nim/issues/3382}

  \bibitem{rust}
    \eresource{The Rust Programming Language}{https://www.rust-lang.org/}
  \bibitem{rust:mozilla}
    \eresource{The Rust Language | Lambda the Ultimate}{http://lambda-the-ultimate.org/node/4009}
  \bibitem{llvm}
    \eresource{The LLVM Compiler Infrastructure Project}{http://llvm.org/}

  \bibitem{synthesis}
    Massalin H. Synthesis: An Efficient Implementation of Fundamental Operating System Services. --- Columbia University, 1992. --- 158 c.

  \bibitem{cortex-m}
    \eresource{Cortex-M -- Arm}{https://www.arm.com/products/processors/cortex-m}
  \bibitem{cortex-m:stm}
    \eresource{STM32 ARM Cortex Microcontrollers - 32-bit MCUs - STMicroelectonics}{http://www.st.com/en/microcontrollers/stm32-32-bit-arm-cortex-mcus.html}
  \bibitem{processor-sleep}
    \eresource{Advanced Sleep-Mode Techniques for Enhanced Battery Life in Real-Time Environments | DigiKey}{https://www.digikey.com/en/articles/techzone/2011/dec/advanced-sleep-mode-techniques-for-enhanced-battery-life-in-real-time-environments}
  \bibitem{hardware-is-cheap}
    \eresource{Hardware is Cheap, Programmers are Expensive}{https://blog.codinghorror.com/hardware-is-cheap-programmers-are-expensive/}
  \bibitem{misra}
    \eresource{MISRA - The Motor Industry Software Reliability Association}{https://www.misra.org.uk/}
  \bibitem{worst-practices-should-be-hard}
    \eresource{Haskell for all: Worst practices should be hard}{http://www.haskellforall.com/2016/04/worst-practices-should-be-hard.html}
  \bibitem{heartbleed}
    \eresource{Heartbleed Bug}{http://heartbleed.com/}
  \bibitem{blueborne}
    \eresource{Let's talk about Blueborne, the latest Bluetooth vulnerability}{https://www.androidcentral.com/lets-talk-about-blueborne-latest-bluetooth-vulnerability}
  \bibitem{oop-must-die}
    \eresource{Object Oriented Programming is an expensive disaster which must end | Smash Company}{http://www.smashcompany.com/technology/object-oriented-programming-is-an-expensive-disaster-which-must-end}

  \bibitem{an-empirical-study-of-operating-systems-errors}
    \eresource{An Empirical Study of Operating Systems Errors}{https://pdos.csail.mit.edu/archive/6.097/readings/osbugs.pdf}
  \bibitem{linux-kernel-developer-responses}
    \eresource{Linux Kernel Developer Responses to Static Analysis Bug Reports}{https://www.usenix.org/legacy/event/usenix09/tech/full_papers/guo/guo_html/index.html}
  \bibitem{40-variability-bugs}
    \eresource{40 Variability Bugs in the Linux Kernel. A Qualitative Study}{https://pure.itu.dk/ws/files/74775263/ITU_TR_2014_180.pdf}

  \bibitem{array-slicing}
    \eresource{Array slicing - Wikipedia}{https://en.wikipedia.org/wiki/Array\_slicing}
  \bibitem{haskell:type-wildcards}
    \eresource{7.15 Partial Type Signatures}{https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/partial-type-signatures.html}
  \bibitem{c++:enums}
    \eresource{enumeration declaration - cppreference.com}{http://en.cppreference.com/w/cpp/language/enum#Scoped_enumerations}

\end{thebibliography}

% \appendix
% \chapter{}

\finalizepart{}

\end{document}
