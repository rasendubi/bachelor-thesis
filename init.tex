\documentclass[oneside,14pt,a4paper,final]{myextreport}

\usepackage{fontspec}
% polyglossia is an alternative to babel for XeLaTeX
\usepackage{polyglossia}

\defaultfontfeatures{Ligatures={TeX}}
\setmainfont{Times New Roman}
\setsansfont{Comic Sans MS}
\setmonofont{Courier New}

\newfontfamily\cyrillicfont{Times New Roman}
\newfontfamily\cyrillicfonttt{Courier New}

% for some reason polyglossia doesn't define \No itself
\providecommand\No{\char"2116}%{№}%

\setmainlanguage{ukrainian}
\setotherlanguage{english}

% indent first paragraph
\usepackage{indentfirst}

% single space between sentences
\frenchspacing

% enable \url command
\usepackage[hyphens]{url}
% don't create boxes around links
\usepackage[
  colorlinks=false,
  pdfborder={0 0 0},
  % don't create links in table of content
  %
  % This allows dirty hacks
  linktocpage=true,
]{hyperref}

% don't really know, but it should make pages somewhat better
\usepackage{microtype}

% don't allow word overflows
\sloppy

% a half spacing
\usepackage{setspace}
\setstretch{1.5}
%\doublespacing{}
%\onehalfspacing{}

% table of acronyms
\usepackage{acronym}

% titles formatting
\usepackage{titlesec}
\titleformat{\chapter}[display]{\filcenter}{\bfseries\MakeUppercase{\chaptertitlename} \thechapter}{0pt}{\bfseries\MakeUppercase}{}
% in case previous setup was right
%\titleformat{\chapter}[hang]{\filcenter}{\bfseries\MakeUppercase{\chaptertitlename} \thechapter. }{0pt}{\bfseries\MakeUppercase}{}

\titleformat{\section}{\normalsize\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}
\titlespacing*{\chapter}{0pt}{0pt}{\baselineskip}
% these were {*4}{*4}
\titlespacing*{\section}{\parindent}{*2}{*2}
\titlespacing*{\subsection}{\parindent}{*2}{*2}

% Table of content customization
\usepackage{tocloft}

% Don't hyphenate chapter names
\usepackage{hyphenat}

% This block is a dirty hack to make TOC entries uppercase
%
% Well, know when I forked the document class can I make this change in
% the class itself.
\usepackage{etoolbox}
\makeatletter
\patchcmd{\l@chapter}{#1}{\MakeUppercase{\nohyphens{#1}}}{}{}
\makeatother

% Table of content customization
\renewcommand{\cfttoctitlefont}{\hspace{0.38\textwidth} \bfseries\MakeUppercase}
\renewcommand{\cftbeforetoctitleskip}{-1em}
\renewcommand{\cftaftertoctitle}{\vspace{-2.5em}}
%\renewcommand{\cftaftertoctitle}{\mbox{}\hfill \\ \mbox{}\hfill Арк.\vspace{-2.5em}}

\renewcommand{\cftchapdotsep}{1}
\renewcommand{\cftchapfont}{}
\renewcommand{\cftchappagefont}{}
\renewcommand{\cftchapleader}{\cftdotfill{\cftchapdotsep}}

\renewcommand{\cftchappresnum}{\MakeUppercase{\chaptername} }
\renewcommand{\cftchapaftersnum}{.}
\renewcommand{\cftchapaftersnumb}{}

%\newlength{\mylength}
%\settowidth\mylength{\cftchappresnum\cftchapaftersnum\space}
%\addtolength{\cftchapnumwidth}{\mylength}
\settowidth\cftchapnumwidth{\cftchappresnum\cftchapaftersnum}

%\renewcommand{\cftsecfont}{\hspace{31pt}}
%\renewcommand{\cftsubsecfont}{\hspace{11pt}}
\renewcommand{\cftbeforechapskip}{0mm}
\renewcommand{\cftparskip}{-1mm}
\renewcommand{\cftdotsep}{1}
\setcounter{tocdepth}{2}

% Add bibliography to the toc
\usepackage[nottoc]{tocbibind}

% Set name for bibliography
\AtBeginDocument{\renewcommand\bibname{Список використаних джерел}}

% Redefine a bibliography label
\makeatletter
\renewcommand\@biblabel[1]{#1.}
\makeatother

% Add command for referencing electronic resources
\newcommand{\eresource}[2]{#1. [Електронний ресурс]. --- Режим доступу: \url{#2}}

% text geometry
\hoffset=-1in
\voffset=-1in
% A4: 210 297
% 185 - 20 = 165
\textwidth=165mm
% 287-15 - 20 = 252
\textheight=252mm
% 210(page) - 185(frame) - 5(right margin) + 10(text padding)
\oddsidemargin=30mm
\headheight=14pt
\headsep=10mm
\topmargin=1.5mm

% https://bitbucket.org/fat_angel/opengostfont/downloads
\newfontfamily{\GostA}[
  Path=fonts/,
  SlantedFont=OpenGostTypeA-Regular,
  SlantedFeatures={FakeSlant=0.25},
  Scale=MatchLowercase,
]{OpenGostTypeA-Regular}
\newfontfamily{\GostB}[
  Path=fonts/,
  SlantedFont=OpenGostTypeB-Regular,
  SlantedFeatures={FakeSlant=0.25},
  Scale=0.90
]{OpenGostTypeB-Regular}

% GOST frames
\unitlength=1mm

% renewcommand when stamp code changes
\newcommand\stampcode{}
\newcommand\lastpagelabel{}

\def\VL{\line(0,1){15}}
\def\Box#1#2{\parbox[top][5mm][t]{#1}{\centering #2}}

\newcommand\thin{\linethickness{0.3mm}}
\newcommand\thick{\linethickness{0.5mm}}
\def\firstGrad{\small\noindent\hbox to 0pt{%
    \vbox to 0pt{%
      \noindent\begin{picture}(185,287)(10,0)
      \thick\put(0,0){\framebox(185,287){}}

      \thin \put(0,5){\line(1,0){65}}
      \thin \put(0,10){\line(1,0){65}}
      \thin \put(0,15){\line(1,0){65}}
      \thin \put(0,20){\line(1,0){65}}
      \thick\put(0,25){\line(1,0){185}}
      \thick\put(0,30){\line(1,0){65}}
      \thin \put(0,35){\line(1,0){65}}
      \thick\put(0,40){\line(1,0){185}}

      \thick\put(135,15){\line(1,0){50}}
      \thick\put(135,20){\line(1,0){50}}

      \thick
      \put(7,40){\line(0,-1){15}}
      \put(17,40){\line(0,-1){40}}
      \put(40,40){\line(0,-1){40}}
      \put(55,40){\line(0,-1){40}}
      \put(65,40){\line(0,-1){40}}
      \put(135,25){\line(0,-1){25}}
      \put(150,25){\line(0,-1){10}}
      \put(165,25){\line(0,-1){10}}

      \put(150,15){\Box{15mm}{\sl\GostB \thepage}}
      \put(165,15){\Box{20mm}{\sl\GostB \pageref{\lastpagelabel{}}}}

      \thin
      \put(140,20){\line(0,-1){5}}
      \put(145,20){\line(0,-1){5}}

      \put(65,25){\makebox(120,15){\large\GostA\stampcode}}

      \put(1,0){\Box{17mm}{\raggedright \sl\GostB Затверд.}}
      \put(1,5){\Box{17mm}{\raggedright \sl\GostB Н. Контр.}}
      \put(1,15){\Box{17mm}{\raggedright \sl\GostB Перевір.}}
      \put(1,20){\Box{17mm}{\raggedright \sl\GostB Розроб.}}

      \put(0,25){\Box{7mm}{\sl\GostB Змн.}}
      \put(7,25){\Box{10mm}{\sl\GostB Арк.}}
      \put(17,25){\Box{23mm}{\sl\GostB \No~докум.}}
      \put(40,25){\Box{15mm}{\sl\GostB Підпис}}
      \put(55,25){\Box{10mm}{\sl\GostB Дата}}

      \put(135,20){\Box{15mm}{\sl\GostB Літ.}}
      \put(150,20){\Box{15mm}{\sl\GostB Арк.}}
      \put(165,20){\Box{20mm}{\sl\GostB Аркушів}}
      \end{picture}
    }
  }
}

\def\simpleGrad{\small\noindent\hbox to 0pt{%
    \vbox to 0pt{%
      \noindent\begin{picture}(185,287)(10,0)
      \linethickness{0.5mm}
      \put(0,0){\framebox(185,287){}}
      \put(0,0){\Box{7mm}{\sl\GostB Змн.}}
      \put(0,15){\line(1,0){185}}
      \put(0,5){\line(1,0){65}}
      \linethickness{0.3mm}
      \put(0,10){\line(1,0){65}}
      \linethickness{0.5mm}
      \put(7,0){\VL\Box{10mm}{\sl\GostB Арк.}}
      \put(17,0){\VL\Box{23mm}{\sl\GostB \No~докум.}}
      \put(40,0){\VL\Box{15mm}{\sl\GostB Підпис}}
      \put(55,0){\VL\Box{10mm}{\sl\GostB Дата}}
      \put(65,0){\VL\makebox(110,15){\large\GostA\stampcode}}
      \put(175,8){\parbox[top][7mm][t]{10mm}{\centering \sl\GostB Арк.}}
      \put(175,0){\VL\makebox(10,8){\sl\GostA\normalsize\thepage}}
      \put(175,8){\line(1,0){10}}
      \end{picture}
    }
  }
}

% insert GOST frames into headers
\usepackage{fancyhdr}

\fancypagestyle{plain}{%
  \fancyhf{}
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
  \lhead{\firstGrad}
}

\fancypagestyle{normal}{%
  \fancyhf{}
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
  \lhead{\simpleGrad}
}

\pagestyle{normal}

\newcommand{\finalizepart}{
  \label{\lastpagelabel{}}
}
\newcommand{\newpart}[2]{
  \finalizepart{}
  \clearpage
  \setcounter{page}{1}
  \enlargethispage{-25mm}
  \renewcommand\stampcode{#2}
  \renewcommand\lastpagelabel{PartLastPage#1}
  \thispagestyle{plain}
}
\AtEndDocument{\finalizepart{}}

% list with less spacing ( \begin{itemize}[nosep] )
\usepackage{enumitem}

\newcommand{\specialchapter}[1]{\chapter*{#1}\addcontentsline{toc}{chapter}{#1}}
\newcommand{\specialsection}[1]{\section*{#1}\addcontentsline{toc}{section}{#1}}

\newcommand{\chapterconslusions}{
  \specialsection{Висновки до розділу \thechapter}
}

\newcommand\code[1]{{\tt #1}}
%\newcommand\code[1]{#1}

\begin{document}

% \chapter{Технічне завдання для дипломного проекту}
% \section{Найменування і область застосування}
% \section{Підстави для розробки}
% \section{Мета і призначення розробки}
% \section{Джерела розробки}
% \section{Технічні вимоги}
% \subsection{Вимоги до розроблюваного продукту}
% \subsection{Вимоги до програмного забезпечення}
% \section{Етапи розробки}

\newpart{part3}{ІАЛЦ.467100.003.ПЗ}
\tableofcontents

% I'm not yet sure, I need a translation, so that may change in the
% future
\newcommand\engacro[3]{\acro{#1}{(#2) #3}}

\specialchapter{Список скорочень}
\begin{acronym}[TCP/IPA]
  \engacro{AST}{Abstract Syntax Tree}{Абстрактне Синтаксичне Дерево}
  \acro{CAN}{Controller Area Network}
  \acro{CPU}{Central Processing Unit}
  \acro{DOSFS}{FAT-based file system}
  \engacro{EDSL}{Embedded Domain-Specific Language}{Вбудована Предметно-Орієнтована Мова}
  \acro{FPU}{Floating Point Unit}
  \acro{HRFS}{High Reliability File System}
  \engacro{IoT}{Internet of Things}{Інтернет Речей}
  \acro{MMU}{Memory Management Unit}
  \acro{NFS}{Network File System}
  \acro{RAM}{Random Access Memory}
  \acro{ROM}{Read-Only Memory}
  \acro{RTOS}{Real-Time Operating System}
  \acro{SLOB}{Simple List of Blocks}
  \acro{SoC}{System on Chip}
  \acro{TCP/IP}{Transport Control Protocol/Internet Protocol}
  \acro{USB}{Universal Serial Bus}
\end{acronym}

\specialchapter{Вступ}

У наші дні активно відбувається мініатюрізація пристроїв, швидкими темпами розвивається Інтернет Речей (Internet of Things, IoT). Гігантськими кроками збільшується кількість пристроїв, що підключені до Інтернету. Експерти оцінюють, що до 2020-го року буде існувати до 50 мільярдів підключених пристроїв\cite{dave-evans:IoT}.

Це означає, що складність програмного забезпечення для вбудованих пристроїв буде зростати, оскільки їм тепер необхідно взаємодіяти з іншими пристроями за допомогою Інтернету, водночас зберігаючи довгу тривалість роботи і надзвичайно низькі вимоги до ресурсів.

Таким чином, вбудовані пристрої вимагають систем управління, що будуть полегшувати організацію складної роботи, зменшувати кількість помилок програміста, і водночас мати мінімальні вимоги до ресурсів процесора і оперативної пам'яті, бути легко переносимими на інші платформи і архітектури.

У рамках даної бакалаврської роботи ставиться завдання розробити систему управління для пристроїв з мінімальним обсягом пам'яті. Головною метою роботи є розробка такої системи для мікроконтроллера STM32F407VGT6, що має має 192 Кб оперативної пам'яті. Однак, система має використовувати мінімум оперативної пам'яті і бути легко портованою на значно менш потужні мікроконтролери. Додатковою метою ставить оцінка сучасних інструментів, зокрема мов програмування, у рамках створення програмного забезпечення для вбудованих пристроїв.

При створенні програмного продукту було пройдено повний цикл його написання -- від постановки завдання, написання технічного завдання і вимог до продукту, до написання програмного забезпечення та тестування.

\chapter{Операційні системи для вбудованих пристроїв}
\section{Загальні положення}

\section{Огляд існуючих рішень}
\subsection{Embedded Linux}

Ядро Linux\cite{linux} пропонує широкий набір функціоналу, серед якого можна знайти безліч драйверів, підтримка великої кількості файлових систем, широкий вибір планувальників і алокаторів пам'яті. Однак, для зниження системних вимог, доводиться відмовлятися від більшості функцій, що надає ядро Лінукс.

Ядро Linux було портовано на велику кількість архітектур, в число яких входять такі як ARM, AVR32, MIPS, Xtensa. Ці архітектури використовуються у вбудованих системах. Однак Linux висуває досить високі вимоги до ресурсів системи. Мінімальний обсяг оперативної пам'яті, що вимагає система, дорівнює 4 мегабайтам, також Лінукс вимагає наявності \ac{MMU}, що перешкоджає його використанню в системах на нижній границі потужностей.

Незважаючи на це, Том Занусі модифікував ядро Лінукс і портував його на Intel Galileo\cite{linux-galileo}. Ця плата базована на мікроконтроллері Intel Quark SoC X1000, що має архітектуру Pentium і 512 кілобайт вбудованої оперативної пам'яті\cite{intel-galileo}.

Ядро розповсюджується під вільною ліцензією GPLv2.

\subsection{VxWorks}

VxWorks\cite{vxworks} це операційна система реального часу зозроблена як власницьке програмне забезпечення Wind River. VxWorks призначена для вбудованих систем реального часу, що вимагають детермінованої продуктивності, і часто, проходження сертифікації безпеки і захищенності.

VxWorks підтримує архітектури Intel x86, MIPS, PowerPC, Freescale ColdFire, Intel i960, SPARC, Fujitsu FR-V, SH-4, ARM, StrongARM і xScale, і може працювати y режимах симетричної, асиметричної і змішаної багатопроцесорної обробки. Операційна система включає у себе багатозадачне ядро з витісняючим планувальником, засоби міжпроцесорної взаємодії і синхронізації, стек протоколів Bluetooth, \acs{TCP/IP}, \acs{USB}, \acs{CAN}, а також файлові системи \ac{HRFS}, \acs{DOSFS}, \ac{NFS}.

Мінімальний обсяг оперативної пам'яті дорівнює 20-ти кілобайтам.

VxWorks активно використовується в аерокосміній, захисній, автомобільній і робототехнічній галузях. Відомими прикладами використання є марсоходи Sojourner, Spirit, Opportunity\cite{vxworks:rovers}, загальна система ядра Boeing 787 Dreamliner\cite{vxworks:boeing}.

\subsection{FreeRTOS}

Насьогодні, FreeRTOS\cite{freertos} є найпопулярнішою операційною системою реального часу для вбудованих систем\cite{freertos:popular}. Її було портовано на 35 мікроконтроллерів, що мають наступні архітектури: ARM, AVR, HCS12, MicroBlaze, Cortus, MSP430, PIC, Renesas~ H8/S, SuperH, RX, x86, 8052, Coldfire, V850, 78K0R, Fujitsu MB91460, Nios~ II, TMS570, RM4x.

Це дуже проста операційна система, що складається з чотирьох файлів на мові C. FreeRTOS надає методи для роботи з потоками, м'ютексами і семафорами, таймерами і чергами. Підтримується так званий tickless режим роботи (у цьому режимі переривання таймера відбуваються при нерівних інтервалах, і лише в міру необхідності).

Доступні чотири алокатори пам'яті:
\begin{itemize}
  \item Виділення пам'яті без можливості її звільнення.
  \item Простий алгоритм виділення і звільнення пам'яті без об'єднання вільних ділянок.
  \item Більш складний і швидкий алгоритм виділення і звільнення пам'яті з об'єднанням вільних ділянок.
  \item Обгортки навколо стандартної бібліотеки, що забезпечують взаємне виключення.
\end{itemize}

FreeRTOS має надзвичайно низькі вимоги до оперативної пам'яті. Планувальник вимагає 236 байт оперативної пам'яті, плюс 76 байти для кожної черги і 64 байти для кожної задачі.

Ядро розповсюджується під модифікованою вільною ліцензією GPLv2\cite{freertos:license}. Модифікація дозволяє залишати закритим код додатків, що використовують FreeRTOS і розповсюджуються у вигляді виконуваного коду, а також забороняє використання FreeRTOS у еталонних теста. Також доступна комерційна підтримка і ліцензія під ім'ям OpenRTOS\cite{openrtos}.

\subsection{QNX Neutrino}

QNX\cite{qnx} це комерційна Unix-подібна операційна система спрямована в першу чергу на вбудовані системи. Операційна система має мікроядерну архітектуру. QNX Neutrino була портована на велику кількість платформ і працює на Intel 8088, x86, MIPS, PowerPC, SH-4, ARM, StrongARM, XScale.

Ядро QNX містить лише планувальник задач, міжпроцесну взаємодію, перенаправлення переривань і таймери. Все інше виконується як процеси рівня користувача, включаючи керування пам'яттю.

QNX має закриту ліцензію, але також має окрему ліцензію для академічного і некомерційного використання\cite{qnx:noncommercial}.

% \subsection{Contiki}

\chapterconslusions{}
% TODO

\chapter{Аналіз і вибір мови програмування}

%\newcommand\LangC{Сі}
\newcommand\LangC{C}

\section{Загальні вимоги}

Програмування мікроконтролерів висуває певні вимоги до мови.

По-перше, мова має бути компілюєма, оскільки на дешевих мікроконтролерах дуже мало ресурсів для інтерпретації мови, або її компіляції. На більших платформах, інтерпретація можлива, але однаково вимагає додаткових витрат процесорного часу і пам'яті. Оскільки дана робота розглядає реалізацю операційної системи, що буде вимагати мінімального обсягу пам'яті, інтерпретація мови на мікроконтроллері неможлива.

По-друге, мова не повинна вимагати збирача сміття, або будь-якого іншої бібліотеки середовища виконання. Як і з інтерпретацією, це вимагає додаткових ресурсів, якими мікроконтролер часто не володіє.

По-третє, низькорівневе програмування схильне до програмних помилок, що важко знайти і виправити. На відміну від прикладного програмування, помилки на системному рівні частіше призводять до краху усієї системи. До найчастіших помилок можна віднести помилки виходу за границі буферу, помилки при роботі з динамічною пам'яттю, витік ресурсів, помилки синхронізації, виклик заборонених у певному контексті функцій. Це означає, що мови системного програмування мають приділяти особливу увагу питанню безпеки.

Також, для програмування операційних систем дуже важлива можливість контролювати розмітку пам'яті і робота з пам'яттю напряму. Додатковими плюсами є можливість вбудови асемблерних інструкцій, взаємодія з іншими мовами (зокрема мовою асемблера і \LangC{}), наявність якісного компілятора, що генерує швидкий код.

\section{C}

Мову \LangC{} було розроблено у 1972 році Денісом Рітчі у Bell Telephone Labaratories з метою написання операційної системи UNIX\cite{stewart-bill:history-of-c}. \LangC{} є однією із найпопулярніших у світі мов програмування за кількістю вже написаного програмного забезпечення, а також кількості програмістів.

Мова \LangC{} надає можливості прямого доступу до пам'яті, майже повний контроль над пам'яттю і потоком виконання, не має збирача сміття, або будь-якої бібліотеки середовища виконання. Також, \LangC{} має просту домовленість про виклики, що дозволяє легко використовуваи функції, написані на \LangC{}, майже з будь-якої іншої мови програмування, включаючи мову асемблера. Існують дуже потужні і стабільні компілятори, що генерують високоефективний машиний код. Все це робить \LangC{} гарним кандидатом.

Мова \LangC{} є \emph{де-факто} стандартом для написання вбудованих систем. Це перевірений роками інструмент, що довів свою ефективність і показав себе найкращим у класі вбудованих систем.

Однак, \LangC{} не можна назвати сучасною мовою. Її було розроблено майже 50 років тому і сьогодні не ведеться активних розробок з покращення і розвинення мови. Останній стандарт (C11) було випущено у 2011 році, але він вносить лише незначні покращення і не виправляє багатьох фундаментальних проблем мови \LangC{}.

Однією із серйозних проблем \LangC{} є типізація. Мова \LangC{} має слабку статичну типізацію; це означає, що всі типи перевіряються на етапі компіляції, але існують неявні приведення типу, що досить часто призводить до програмних помилок. Також, система типів є дуже примітивною, і не має корисних функцій, що характерні більш сучасним системам типів.

\section{Idris}

Мова Idris\cite{idris} є чисто-функціональною мовою програмування з потужною системою типів, що підтримує залежні типи. Розробка мови ведеться з 2009 року\cite{idris:first-release}, тож мова є дуже молодою.

Насьогодні, залежні типи не є широко-використовуваною технологією у програмуванні і використовуються здебільшого у науковому середовищі, а також ентузіастами мов програмування. Залежні типи стирають межу між типами і значеннями; типи стають звичайними значеннями, що дозволяє виконувати операції над типами, передавати їх як аргументи функцій і повертати їх із функцій. Тож можна мати різний тип в залежності від результатів обчислення певного значення, або іншого типу.

За допомогою залежних типів в Idris було побудовано систему ефектів. Система ефектів дозволяє розділити використання певних дій від їх конкретної реалізації. Наприклад, функція може використовувати функції логування, однак вибір їх конкретної реалізації залишається на функції, що врешті решт викличе виконання ефекту. Це можна назвати формою впровадження залежностей (dependency injection). 

% TODO: example

Система ефектів також дозволяє керувати і розмежовувати доступ повних функції до певних ефектів. Наприклад, можна створити ефект для роботи з мережею; тоді можна обмежувати доступ до мережевих операцій на рівні окремих функцій -- компілятор може гарантувати під час компіляції, що певна функція не буде використовувати функції роботи з мережею.

Система ефектів і залежні типи можуть підвищити рівень надійності операційних систем, якщо правильно їх використовувати. За допомогою створення окремого класу блокуючих операцій, можна позбавитися від цілого класу проблем, що виникають при виклику блокуючих операцій з обробнику переривань. За допомогою ще інакшого ефекту, можна гарантувати вивільнення ресурсів, як то пам'ять або відкриті файлові дескриптори. За допомогою залежних типів можна накладати обмеження на виділення оперативної пам'яті, або навіть на кількість тактів процесора для певних функцій. В цілому, залежні типи це дуже потужних механізм для забезпечення перевірки певних припущень у самомоу коді програми і математичного доведення правильності програми.

Нажаль, Idris вимагає збирача сміття і великої бібліотеки часу виконання, що унеможливлює використання Idris напряму для створення програмного забезпечення для систем з обмеженою пам'яттю. Але можливо створити EDSL (embedded domain-specific language, вбудована предметно-орієнтована мова) на базі Idris для генерація коду для вбудованих систем і таким чином позбутися даних обмежень мови. Схожим чином було реалізовано мови Atom\cite{haskell:atom} і Ivory\cite{haskell:ivory}, але на базі мови Haskell\cite{haskell}.

\section{Nim}

Мова Nim\cite{nim} (раніше Nimrod) вперше зв'явилася у 2008 році. Це багатопарадигмена мова, що компілюється у Javascript або \LangC{}, має сильну статичну типізацію і простий синтаксис. Nim має багаті можливості узагальненого (Generics), об'єктно-орієнтованого і шаблонного програмування. Особливо варто відмітити багаті можливості для обчислень під час компіляції. Макроси дозволяють змінювати AST (Abstract Syntax Tree, Абстрактне Синтаксиче Дерево) програми під час компіляції; за допомогою них можна як робити обчислення під час компіляції, так і змінювати синтаксис мови і розширювати його.

Nim також має спрощену систему ефектів. На відміну від системи ефектів в Idris, система ефектів в Nim дозволяє лише маркувати функції різними ефектами i відслітковувати їх. Цього достатньо для того, щоб уникнути програмних помилок пов'язаних з викликом функцій, що заборонені у даному контексті, однак, системи типів Nim не вистачає, щоб гарантувати вивільнення ресурсів, або робити більш складні речі з типами (наприклад, неможливо будувати докази).

Також, Nim має велику кількість директив компілятора\cite{nim:directives}, що можуть бути цікаві під час низькорівневого програмування. Однією із таких директив є прагма \code{effects}, яка і є вже оговореною системою ефектів. Також цікавою є пара прагм \code{guard} і \code{locks}, що дозволяють гарантувати використання промаркованих ресурсів у багатопотокових програмах використовуючи блокування. При цьому, Nim може гарантувати правильний порядок захоплення ресурсів за допомогою рівнів.

Nim має цілу низку директив компілятора, що дозволяють вставляти код написаний на мові \LangC{}, C++, або Objective-C. Це може бути дуже зручним, якщо необхідно багато взаємодіяти з іншими бібліотеками написаними на цих мовах.

За рахунок прагм Nim є дуже загальною мовою програмування, що можна використовувати для широкого спектру задач і середовищ. За допомогою директив компілятора можна контролювати передачу аргументів функцій (за значенням, за посиланням), можна вказувати підказки оптимізатору (розгортка циклів, вбудова викликів функцій, позначення для функцій, що не повертаються або не мають побічних ефектів), можна точно керувати схемою пам'яті (бітові поля, вирівнювання полів, генерація стек-фреймів), також збірник сміття є опціональним і його можна виключити за необхідності.

Нажаль, під час більш детального аналізу було виявлено серйозний недолік в реалізації компілятора. Прагму \code{volatile} було реалізовано некоректно\cite{nim:volatile}, що унеможливило нормальне використання мови для низькорівневого програмування.

\section{Rust}

Rust\cite{rust} це молода багатопарадигмена компілюєма мова для системного програмування, що активно розвивається. Мова вперше з'явилася у 2010 році і була розроблена компанією Mozilla\cite{rust:mozilla}. Мова націлена на безпечне і багатопотокове програмування і має низку особливостей, що цьому допомагають.

Основною функціональною особливістю мови є потужна система типів. Типізацію у Rust є статичною і сильною, що дозволяє уникнути широкого класу помилок зумовлених неявним приведенням типів. Система типів у Rust також є лінійною; це характеристика, що дозволяє уникати помилок розділення ресурсів у багатопотоковому програмуванні за допомогою системи типів (без блокування). Система типів у Rust дозволяє мати лише одне посилання на об'єкт, за яким можна змінювати його, або безліч посилань, за якими можна лише зчитувати дані. Неможливо одночасно мати два посилання на об'єкт, що дозволяють зчитувати і змінювати дані. Це дозволяє уникнути багатьох помилок у багатопотоковому програмуванні уже під час компіляції, без будь-яких витрат під час роботи.

Також, Rust має чітке розмежування між так званими безпечним і небезпечним рівнями. У безпечному рівні заборонено використання певних операцій, що можуть призвести до помилок (наприклад, заборонено використання звичайних вказівників на пам'ять). Це дозволяє мові забезпечити певні гарантії. За замовчуванням, функції є безпечними, а для використання небезпечних операцій необхідно позначити функцію або блок коду як небезпечний. Це дозволяє локалізувати код, що може викликати проблеми.

Інує реалізація простої системи ефектів у вигляді бібліотеки.

Rust також надає багато можливостей, що необхідні для низькорівневого програмування: точне керування схемою пам'яті, гарну взаємодію з мовою \LangC{}, відсутність збірника сміття і бібліотеки часу виконання. Компілятор Rust використовує LLVM\cite{llvm} для компіляції, що дозволяє йому генерувати ефективний код для великої кількості платформ.

Rust також має синтаксис дуже схожий до мови \LangC{}, що є плюсом для широкого розповсюдження мови, оскільки даний синтаксис є відомим багатьом програмістам.

\chapterconslusions{}

Мова \LangC{} є гарним вибором для комерційного проекту, але не надає ніяких технічних переваг. Використання даної мови не несе собою новизни і не цікаве з точки зору дослідження.

Idris має одну із найпотужніших систем типів насьогодні. Її особливості можна було б використати для створення значно більш надійних операційних систем. Нажаль, Idris вимагає збирача сміття і великої бібліотеки середовища виконання. Це унеможливлює використання Idris для операційних систем для вбудованих пристроїв напряму. Розробка EDSL на Idris може бути виходом, але вимає додаткових затрат.

Nim є дуже цікавою мовою, що має опціональний збиральник сміття і може працювати без бібліотеки середовища виконання. Вона має багато особливостей, що можуть допомогти при написанні низькорівневого програмного забезпечення. Однак, низька якість реалізації компілятора майже унеможливлює використання мови для більш-менш серйозного низькорівневого програмування.

Система типів Rust є гарним компромісом між потужною системою типов Idris, яка вимагає певної підтримки від середовища виконання, і системи типів \LangC{}, що не потребує середовища виконання, але є занадто простою. За допомогою типів, Rust допомагає гарантовано уникнути певного класу помилок, що є розповсюдженими при низькорівневому програмуванні. Також, розділення на безпечні і небезпечні операції дозволяє локалізувати код, що може викликати програмні помилки.

Для виконання даної бакалаврської роботи було обрано мову Rust, оскільки вона компілюється у машинні коди, не має збирача сміття, або будь-якої обов'язкової бібліотеки часу виконання, а система типів надає дуже сучасні можливості для покращення якості коду програми, уникнення широкого спектру програмних помилок і полегшення роботи программіста. Стандартний компілятор є дуже якісним і підтримує широкий спектр платформ.

\chapter{Розробка системи управління}
%\section{Аналіз задачі}
%\section{Вибір програмних та технічних засобів}
%\section{Архітектура розроблюваної системи управління}

%\section{Опис модулів та особливостей їх реалізації}

\section{Алокатор пам'яті}

В рамках даного дипломного проекту було розроблено алокатор пам'яті, що найкращим чином підходить для систем з мінімальним обсягом оперативної пам'яті.

\subsection{Будова алокатора}

Алокатор користується певними особливостями таких систем:
\begin{itemize}
\item Низька кількість пам'яті і невеликі розміри максимальних алокацій.

  Це дозволяє використовувати менше пам'яті для збереження розміру блоку. 16 біт достатньо для збереження максимального блоку розміром 64 кілобайт. Більшість вбудованих систем, що розглядаються у даному дипломному проекті, не виділяють так багато пам'яті за один раз. Більш того, багато систем взагалі не мають такого об'єму оперативної пам'яті.

\item Обов'язкове вирівнювання.

  Багато мікроконтролерів накладають вимоги на вирівнювання пам'яті на границю машиного слова. Так, більшість мікроконтролерів ARM мають вирівнювати пам'ять на границю чотирьох байт. Це означає, що останні два біти в адресі пам'яті завжди є нулями, що дозволяє використати їх для внутрішніх потреб алокатора. За допомогою цієї самої техніки процесори ARM можуть виконувати декілька абсолютно різних набори машиних інструкцій (номер набору інструкцій кодується в двох молодших бітах адреси).

\item Відсутність кешів пам'яті.

  Це робить зайвим реалізацію різних технік кешування блоків пам'яті, оскільки це жодним чином не прискорює алокацію пам'яті або систему в цілому.
\end{itemize}

Розроблений алокатор є \acs{SLOB} алокатором, де всі вільні блоки зв'язані між собою у єдиний список відсортований за зростанням розміру блоку. Таке сортування допомагає пришвидшити best-fit пошук. Всі блоки також зв'язані у двозв'язний список за їх положенням у пам'яті, що робить можливим злиття вільних блоків.

Кожен блок пам'яті має тег, що може включати наступне:

\begin{itemize}
\item 16-бітний розмір попереднього блоку.

  Використовується для обходу блоків у зворотному напрямку.

  Молодший біт використовується для розрізнення між зайнятим і вільним блоком. 0 для зайнятих блоків; 1 -- для вільних.

\item 16-бітний розмір даного блоку.

  Використовується для обходу у прямому порядку.

\item Вказівник на наступний вільний блок (лише для вільних блоків).

  Поле присутнє лише у вільних блоках, тому воно не враховується у загальний розмір тегу.

  Дане поле зв'язує усі вільні блоки за зростанням розміру блоку, що пришвидшує best-fit пошук.
\end{itemize}

Розмір тегу для зайнятих блоків складає 4 байти, що є мінімально-допустимим розміром тегу в огляду на вимоги мікроконтролера до вирівнювання.

\subsection{Алгоритм роботи}

\subsubsection{Алокація}
Алокація пам'яті відбувається за допомогою обходу списку вільних блоків і вибору першого, що має достатній розмір. Фактично, це є best-fit алгоритмом, оскільки список відсортовано за зростанням розміру блоку.

\subsubsection{Деалокація}
Деалокація заключається в позначенні даного блоку як вільного і спробі його злиття з сусідами. При злитті необхідно переконатися, що розмір злитого блоку не перевищить максимальний розмір для блоку.

Після злиття необхідно додати блок до списку вільних блоків, а також вилучити звідки блоки сусідів, якщо вони були злиті.

\subsubsection{Виявлення програмних помилок}
Виявлення програмних помилок зводиться до перевірки наступного інваріанту: розмір попереднього блоку, що збережений у наступному блоці від даного, має дорівнювати розміру даного блоку.

\begin{itemize}
\item Переповнення буферу.

  При звільненні блоку необхідно перевірити що розмір попереднього блоку, що збережений у наступному блоці від даного, дорівнює розміру даного блоку. Якщо це не так, скоріш за все, даний блок було переповнено і тек наступного блоку було перезаписано даними користувача.

\item Подвійне звільнення.

  Якщо даний блок позначено як вільний при спробі його звільнення, значить має місце подвійне звільнення.

\item Звільнення неправильної адреси.

  Якщо інваріант не виконується для даного блоку, є шанс що дана адреса не є початком блоку.

\item Примусова перевірка.

  Можлива виконати примусову перевірку всієї пам'яті. Для цього необхідно обійти всі блоки пам'яті у списку і перевірити інваріант для кожного із них. Дана можливість може бути дуже корисною під час розробки програмного забезпечення.
\end{itemize}

\subsection{Аналіз результатів}

Даний алокатор має низку переваг:
\begin{itemize}[nosep]
\item Низькі накладні витрати.
\item Низька фрагментація пам'яті.
\item Прийнятна швидкодія.
\item Широкий діапазон можливостей для знаходження програмних помилок.
\end{itemize}

\begin{thebibliography}{00}
  \bibitem{linux}
    \eresource{Linux.com | The source for Linux information}{https://linux.com/}
  \bibitem{linux-galileo}
    \eresource{microYocto and the Internet of Tiny}{http://events.linuxfoundation.org/sites/events/files/slides/tom.zanussi-elc2014.pdf}
  \bibitem{intel-galileo}
    \eresource{Galileo Feature Sheet}{http://www.intel.com/content/dam/support/us/en/documents/galileo/sb/galileo\_datasheet\_329681\_003.pdf}

  \bibitem{freertos}
    \eresource{FreeRTOS - Market leading RTOS (Real Time Operating System) for embedded systems with Internet of Things extensions}{http://www.freertos.org/}
  \bibitem{freertos:popular}
    \eresource{Android, FreeRTOS top EE Times' 2013 embedded survey}{http://www.eetimes.com/document.asp?doc\_id=1263083}
  \bibitem{freertos:license}
    \eresource{FreeRTOS License}{http://www.freertos.org/license.txt}
  \bibitem{openrtos}
    \eresource{OPENRTOS, part of embedded FreeRTOS -- OpenRTOS -- SafeRTOS family}{http://www.highintegritysystems.com/openrtos/}

  \bibitem{vxworks}
    \eresource{VxWorks}{http://windriver.com/products/vxworks/}
  \bibitem{vxworks:rovers}
    \eresource{Inside NASA's Curiosity: It's an Apple Airport Extreme... with wheels | ExtremeTech}{http://www.extremetech.com/extreme/134041-inside-nasas-curiosity-its-an-apple-airport-extreme-with-wheels}
  \bibitem{vxworks:boeing}
    \eresource{787 Dreamliner (Common Core Systems) | Customers | AdaCore}{http://www.adacore.com/customers/787-dreamliner-common-core-system/}

  \bibitem{qnx}
    \eresource{QNX Neutrino RTOS}{http://www.qnx.com/products/neutrino-rtos/neutrino-rtos.html}
  \bibitem{qnx:noncommercial}
    \eresource{QNX Neutrino Realtime Operating System}{http://www.qnx.com/download/download.html?dlc=proc&newsearch=yes&searchme=non-commercial&p=1&sort=bydate&sorttype=desc&searchdate=alltime}

  \bibitem{dave-evans:IoT}
    \eresource{The Internet of Things. How the Next Evolution of the Internet is Changing Everything}{http://www.cisco.com/c/dam/en\_us/about/ac79/docs/innov/IoT\_IBSG\_0411FINAL.pdf}
  \bibitem{stewart-bill:history-of-c}
    \eresource{History of C Programming Language}{http://www.livinginternet.com/i/iw\_unix\_c.htm}

  \bibitem{idris}
    \eresource{Idris | A Language with Dependent Types}{http://www.idris-lang.org/}
  \bibitem{idris:first-release}
    \eresource{idris: Dependently Typed Functional Programming Language}{http://hackage.haskell.org/package/idris-0.1.3}
  \bibitem{haskell:atom}
    \eresource{atom: An EDSL for embedded hard realtime applications}{https://hackage.haskell.org/package/atom}
  \bibitem{haskell:ivory}
    \eresource{Ivory - index}{http://ivorylang.org/index.html}
  \bibitem{haskell}
    \eresource{Haskell Language}{https://www.haskell.org/}

  \bibitem{nim}
    \eresource{Nim Programming Language}{http://nim-lang.org/}
  \bibitem{nim:directives}
    \eresource{Nim Manual}{http://nim-lang.org/docs/manual.html\#pragmas}
  \bibitem{nim:volatile}
    \eresource{\{.volatile.\} is almost useless · Issue \# 3382 · nim-lang/Nim}{https://github.com/nim-lang/Nim/issues/3382}

  \bibitem{rust}
    \eresource{The Rust Programming Language}{https://www.rust-lang.org/}
  \bibitem{rust:mozilla}
    \eresource{The Rust Language | Lambda the Ultimate}{http://lambda-the-ultimate.org/node/4009}
  \bibitem{llvm}
    \eresource{The LLVM Compiler Infrastructure Project}{http://llvm.org/}

\end{thebibliography}

\end{document}
